theory SafeSubTPX
  imports AltLBoundLemma SubstTPX SafeSubRename SubstDropEnv
begin  
    
lemma stpa_lift_comp_use_env: "diff_use_env (comp_use_env rx1 rx2) (comp_use_env rx1 (lift_use_env rx2 r)) =
  diff_use_env (comp_use_env rx1 (lift_use_env rx2 r)) (comp_use_env rx1 (lift_use_env rx2 r))"    
  apply (case_tac "\<forall> x. diff_use_env (comp_use_env rx1 rx2) (comp_use_env rx1 (lift_use_env rx2 r)) x =
  diff_use_env (comp_use_env rx1 (lift_use_env rx2 r)) (comp_use_env rx1 (lift_use_env rx2 r)) x")
   apply (auto)
  apply (simp add: diff_use_env_def)
  apply (simp add: comp_use_env_def)
  apply (case_tac "r")
    apply (auto)
  apply (case_tac "rx1 x")
    apply (auto)
   apply (case_tac "rx2 x")
     apply (auto)
  apply (case_tac "rx2 x")
    apply (auto)
  done

    (*
      the hardest part of this lemma is proving end perms r_s3 from end perms r_se + rx2, since usually
      we can only add end perms when we are completely sure that whatever we are adding is disjoint.

      abstractly, the idea is that although we perform the substitution on just rx1, when we put back
      in r_s3, then we expect to get a result which is just rx1 + rx2 subtracted out.

      the idea is that the lambda body, is typed rx1 + rx2 > e > r_se - (rx1 + rx2), r_xe - (rx1 + rx2).
      if we upgrade the start perm to r_s3, then we should have r_s3 > e > r_s3 - (rx1 + rx2), r_xe - (rx1 + rx2).
      the question is how do we actually get this? 
    *)
    
lemma squish_leq_use_env: "\<lbrakk> leq_use_env r_se (diff_use_env r_s r_ex); leq_use_env r_xe r_se; leq_use_env (diff_use_env rxa r_ex) r_xe \<rbrakk> \<Longrightarrow>
  leq_use_env (diff_use_env r_se r_xe) (diff_use_env r_se rxa)"
  apply (simp add: leq_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (case_tac "r_xe x")
    apply (auto)
   apply (case_tac "r_ex x")
     apply (auto)
     apply (case_tac "rxa x")
       apply (auto)
     apply (case_tac "r_se x")
       apply (auto)
    apply (case_tac "rxa x")
      apply (auto)
    apply (case_tac "r_se x")
      apply (auto)
   apply (case_tac "r_se x")
     apply (auto)
  apply (case_tac "r_se x")
    apply (auto)
   apply (case_tac "rxa x")
     apply (auto)
   apply (case_tac "r_ex x")
     apply (auto)
  apply (case_tac "rxa x")
    apply (auto)
  apply (case_tac "r_ex x")
    apply (auto)
  done
    
lemma cancel_refl_leq_use_env: "leq_use_env (diff_use_env (refl_use_env r_s r_x r) (infl_use_env r_s r_x)) r_ex" 
  apply (simp add: leq_use_env_def)
  apply (auto)
  apply (simp add: diff_use_env_def)
  apply (simp add: refl_use_env_def)
  apply (simp add: infl_use_env_def)
  done
    
    (*
      the last big issue is that even though we want to use rx2 as a requirement, we have to use rx' instead.
      so how can we get r_s3 - (rx1 + rx2) from (r_se + rx') - (rx1 - rx')?

      one thing that would make this easier is if we could maintain r_s1 for the start perm. however we need to
      at some point introduce (rx1 - rx'), if only so we can introduce the comp_ex step.

      this is actually perfectly viable, which leaves us only to work with the requirements.

      since we expect rx' to contain only minimal reqs, it will be greater than rx2, unless rx2 is expanded.
      however the parts removed from rx2 will be things that r_ex can correctly subtract.
    *)

lemma subst_type_preserve_app: "\<lbrakk> well_typed (add_env env (Var x) t) delta (add_use_env rx1 (Var x) r) e tau r_se r_xe;
  well_typed env delta r_s2 e' t r_s3 rx2; rx1 (Var x) = NoPerm; x \<in> free_vars e; is_sexp e'; well_formed_delta env delta;
  lam_vars e \<inter> free_vars e' = {}; leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s3;
  (*safe_use_lift rx2 r; safe_type t r;*) disj_use_env rx1 (lift_use_env rx2 r); leq_use_env r_s2 r_s1; leq_use_env rx1 r_s1 \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 (subst_exp e x e') tau (diff_use_env r_s3 (comp_use_env rx1 (lift_use_env rx2 r)))
    (diff_use_env (comp_use_env rx1 rx2) (comp_use_env rx1 (lift_use_env rx2 r)))"
  apply (cut_tac env="env" and ?r_s1.0="r_s2" and e="e'" and tau="t" and ?r_s2.0="r_s3" and rx="rx2" in infl_sexp_wp)
    apply (auto)
    (* prelim: r_xe \<le> rx1 + x *)
  apply (cut_tac r_sc="r_xe" and r_sb="r_se" and r_sa="add_use_env rx1 (Var x) r" in trans_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (rule_tac well_typed_perm_leqx)
   apply (auto)
    (* prelim: lift rx' \<le> lift rx2 + r_ex \<inter> r_s1, therefore lift rx' \<inter> r_s1 *)(*
  apply (cut_tac r_ex="rx1" and r_s="comp_use_env (lift_use_env rx2 r) r_ex" and r_x="lift_use_env rx' r" in disj_leq_use_env2)
    apply (rule_tac disj_comp_use_env2)
     apply (simp)
    apply (rule_tac comm_disj_use_env)
    apply (simp)
   apply (rule_tac st_diff_comp_leq_use_env)
   apply (cut_tac r_s="rx'" and r="r" and r_x="r_ex" in lift_diff_use_env)
   apply (simp)
   apply (rule_tac dist_lift_leq_use_env)
   apply (simp)*)
    (* initial lift of rx2 in reqs *)
  apply (cut_tac ?rx1.0="rx1" and ?rx2.0="rx2" and r="r" in stpa_lift_comp_use_env)
  apply (simp)
    (* end_perm: r_s3 - (rx1 + rx2) << (((r_se - x) + rx2) - (rx1 + rx')) + (r_s3 - (rx1 + rx')) *)
    (* req: (rx1 + rx2) - (rx1 + rx2) >> ((r_xe - x) + rx2) - (rx1 + rx')*)
  apply (rule_tac ?r_s2.0="comp_use_env (diff_use_env (comp_use_env (rem_use_env r_se (Var x)) (lift_use_env rx2 r))
    (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r)))
    (diff_use_env r_s3 (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r)))" and
      rx="diff_use_env (comp_use_env (rem_use_env r_xe (Var x)) (lift_use_env rx2 (r_xe (Var x))))
      (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r))" in well_typed_simul_end_perm)
    (* start_perm: r_s1 >> (rx1 + rx' + r_ex) + (r_s3 - (rx1 + rx')) *)
     apply (rule_tac ?r_s1.0="comp_use_env (comp_use_env (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r)) (infl_use_env r_s2 r_s3))
      (diff_use_env r_s3 (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r)))" in well_typed_incr_start_perm)
    (* comp_cancel into start_perm: r_s1, end_perm: ((r_se - x) + rx2) - (rx1 + rx') *)
      apply (rule_tac well_typed_comp_perms_gen)
    (* end_perm: ((r_se - x) + rx2) - rx' << (((r_se - x) + rx') - (rx1 + rx')) - r_ex. *)
    (* req: ((r_xe - x) + rx2) - rx' >> (((r_xe - x) + rx') - (rx1 + rx')) - r_ex *)
       apply (rule_tac ?r_s2.0="diff_use_env (diff_use_env (comp_use_env (rem_use_env r_se (Var x)) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r))
          (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r))) (infl_use_env r_s2 r_s3)" and
          rx="diff_use_env (diff_use_env (stpx_req (rem_use_env r_xe (Var x)) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) (r_xe (Var x))) (r_xe (Var x)))
          (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r))) (infl_use_env r_s2 r_s3)" in well_typed_simul_end_perm)
    (* diff_cancel into end_perm: ((r_se - x) + rx') - (rx1 + rx'), req: ((r_xe - x) + rx') - (rx1 + rx') *)
          apply (rule_tac well_typed_diff_end_perm)
    (* end_neg lift *)
           apply (rule_tac r_exb="end_neg_use_env r_se (Var x) (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r" in well_typed_diff_decr_end_perm_gen)
             apply (rule_tac t="t" and ?rx1.0="rx1" in subst_type_preserve_x)
                     apply (auto)
    (* basic stpx requirements *)
              apply (rule_tac self_comp_leq_use_env1)(*
             apply (rule_tac safe_lift_comp_use_env)
              apply (simp)
             apply (rule_tac safe_lift_refl_use_env)
             apply (simp)*)
            apply (cut_tac r_s="rx2" and r_x="infl_use_env r_s2 r_s3" and r="r" in lift_comp_use_env)
            apply (simp)
            apply (rule_tac disj_comp_use_env2)
              apply (simp)
             apply (simp add: infl_lift_use_env)
            apply (rule_tac infl_disj_use_env)
            apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
             apply (simp)
            apply (rule_tac self_comp_leq_use_env1)
    (* end neg correctness *)
           apply (rule_tac end_neg_leq_use_env)
           apply (rule_tac self_comp_leq_use_env2)
          apply (rule_tac self_comp_leq_use_env1)
    (*
            apply (simp add: end_neg_use_env_def)
            apply (auto)
             apply (rule_tac self_comp_leq_use_env2)
            apply (rule_tac leq_empty_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac id_leq_use_env)*)
    (* diff cancel correctness *)
          apply (rule_tac self_comp_leq_use_env2)
    (* end perms transformation: we re-order to substitute rx2 << rx2 - r_ex *)
         apply (rule_tac disj_diff_leq_use_env)
          apply (rule_tac comm_disj_use_env)
          apply (rule_tac infl_disj_use_env)
          apply (rule_tac diff_leq_use_env)
          apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
           apply (simp)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac r="r" in rem_add_leq_use_env)
           apply (rule_tac well_typed_perm_leq)
           apply (auto)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac dist_diff_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac self_comp_leq_use_env1)
         apply (rule_tac comp_leq_use_env2)
         apply (rule_tac dist_lift_leq_use_env)
         apply (rule_tac self_comp_leq_use_env1)
(*
         apply (rule_tac r_sb="diff_use_env (comp_use_env (rem_use_env r_se x) (diff_use_env (lift_use_env rx2 r) r_ex)) (comp_use_env rx1 (lift_use_env rx' r))" in trans_leq_use_env)
     (* - to prove the re-ordering, we have to factor out the diff *)
          apply (rule_tac r_sb="diff_use_env (diff_use_env (comp_use_env (rem_use_env r_se x) (lift_use_env rx2 r)) r_ex) (comp_use_env rx1 (lift_use_env rx' r))" in trans_leq_use_env)
           apply (rule_tac fold_dcl_use_env)
           apply (rule_tac dist_diff_leq_use_env_gen)
            apply (rule_tac dist_comp_leq_use_env)
             apply (rule_tac self_comp_leq_use_env1)
            apply (rule_tac comp_leq_use_env2)
            apply (rule_tac dist_lift_leq_use_env)
            apply (simp)
           apply (rule_tac dist_comp_leq_use_env)
            apply (rule_tac self_comp_leq_use_env2)
           apply (rule_tac self_comp_leq_use_env1)
    (* - proving lifting out the diff was valid *)
          apply (rule_tac dist_diff_leq_use_env)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac disj_diff_leq_use_env)
            apply (rule_tac r_s="rx1" in disj_leq_use_env2)
             apply (simp)
            apply (rule_tac r="r" in rem_add_leq_use_env)
            apply (rule_tac well_typed_perm_leq)
            apply (auto)
           apply (rule_tac self_comp_leq_use_env1)
          apply (rule_tac dist_diff_leq_use_env)
          apply (rule_tac self_comp_leq_use_env2)
    (* - proving the initial substitution was correct *)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac self_comp_leq_use_env1)
          apply (rule_tac comp_leq_use_env2)
          apply (rule_tac t="diff_use_env (lift_use_env rx2 r) r_ex" and s="lift_use_env (diff_use_env rx2 r_ex) r" in subst)
           apply (rule_tac outer_lift_diff_use_env)
          apply (rule_tac dist_lift_leq_use_env)
          apply (rule_tac mini_disj_diff_leq_use_env)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac r_s="r_s3" in mini_disj_leq_use_env2)
           apply (simp)
          apply (rule_tac well_typed_perm_leqx)
          apply (auto)
         apply (rule_tac id_leq_use_env)*)
    (* end perm / requirements ordering *)
        apply (rule_tac dist_diff_leq_use_env)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac comp_leq_use_env1)
         apply (rule_tac dist_rem_leq_use_env)
         apply (rule_tac well_typed_perm_leqx)
         apply (auto)
        apply (rule_tac comp_leq_use_env2)
        apply (rule_tac dist_lift_leq_use_env_gen)
        apply (cut_tac r_x="r_xe" and r_s="add_use_env rx1 (Var x) r" and x="Var x" in spec_leq_perm)
         apply (auto)
        apply (simp add: add_use_env_def)
    (* requirements transformation: first we want to remove stpx_req *)
       apply (cut_tac r_s="rx2" and r_x="infl_use_env r_s2 r_s3" and r="r_xe (Var x)" in lift_comp_use_env)
       apply (simp)
       apply (rule_tac r_sb="diff_use_env (diff_use_env (comp_use_env (rem_use_env r_xe (Var x)) (comp_use_env (lift_use_env rx2 (r_xe (Var x))) (lift_use_env (infl_use_env r_s2 r_s3) (r_xe (Var x)))))
           (comp_use_env rx1 (lift_use_env (comp_use_env rx2 (infl_use_env r_s2 r_s3)) r))) (infl_use_env r_s2 r_s3)" in trans_leq_use_env)
        apply (rule_tac lhs_fold_dcl_use_env)
        apply (rule_tac lhs_dist_dcl_use_env)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac self_comp_leq_use_env1)
         apply (rule_tac self_comp_leq_use_env1)
        apply (rule_tac lhs_dist_dcl_use_env)
        apply (rule_tac dist_comp_leq_use_env)    
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac self_comp_leq_use_env1)
        apply (rule_tac r_sb="diff_use_env (lift_use_env (infl_use_env r_s2 r_s3) r) (infl_use_env r_s2 r_s3)" in trans_leq_use_env)
         apply (simp add: infl_lift_use_env)(*
         apply (cut_tac ?r_s1.0="r_s2" and ?r_s2.0="r_s3" and r="r" in lift_refl_use_env)
         apply (auto)*)
         apply (rule_tac diff_infl_leq_use_env)
        apply (rule_tac dist_diff_leq_use_env_gen)
         apply (rule_tac dist_lift_leq_use_env_gen)
         apply (cut_tac r_x="r_xe" and r_s="add_use_env rx1 (Var x) r" and x="Var x" in spec_leq_perm)
          apply (simp)
         apply (simp add: add_use_env_def)
        apply (rule_tac self_comp_leq_use_env2)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac stpx_req_leq_use_env)
       apply (rule_tac id_leq_use_env)
(*
       apply (rule_tac r_sb="diff_use_env (diff_use_env (comp_use_env (rem_use_env r_xe x) (lift_use_env rx' (r_xe x))) (comp_use_env rx1 (lift_use_env rx' r))) r_ex" in trans_leq_use_env)
    (* - then we re-order to substitute rx2 >> rx' - (rx' + r_ex) *)
        apply (rule_tac r_sb="diff_use_env (comp_use_env (rem_use_env r_xe x) (diff_use_env (lift_use_env rx' (r_xe x)) (comp_use_env rx' r_ex))) (comp_use_env rx1 (lift_use_env rx' r))" in trans_leq_use_env)
         apply (rule_tac dist_diff_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac self_comp_leq_use_env1)
         apply (rule_tac comp_leq_use_env2)
         apply (rule_tac t="diff_use_env (lift_use_env rx' (r_xe x)) (comp_use_env rx' r_ex)" and s="lift_use_env (diff_use_env rx' (comp_use_env rx' r_ex)) (r_xe x)" in subst)
          apply (rule_tac outer_lift_diff_use_env)
         apply (rule_tac dist_lift_leq_use_env)
         apply (rule_tac r_sb="diff_use_env rx' r_ex" in trans_leq_use_env)
          apply (simp)
         apply (rule_tac dist_diff_leq_use_env_gen)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac self_comp_leq_use_env2)
    (* - in order to prove the re-ordering, we factor out the diff on the rhs *)
        apply (rule_tac r_sb="diff_use_env (diff_use_env (comp_use_env (rem_use_env r_xe x) (lift_use_env rx' (r_xe x))) (comp_use_env rx' r_ex)) (comp_use_env rx1 (lift_use_env rx' r))" in trans_leq_use_env)
         apply (rule_tac dist_diff_leq_use_env)
         apply (rule_tac lhs_dist_dcl_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac self_diff_leq_use_env)
         apply (rule_tac self_comp_leq_use_env2)
        apply (rule_tac fold_dcl_use_env)
        apply (rule_tac dist_diff_leq_use_env_gen)
         apply (rule_tac id_leq_use_env)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac comp_leq_use_env1)
          apply (rule_tac comp_leq_use_env2)
          apply (rule_tac self_lift_leq_use_env)
         apply (rule_tac self_comp_leq_use_env2)
        apply (rule_tac self_comp_leq_use_env1)
    (* - back to the stpx_req *)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac stpx_req_leq_use_env)
       apply (rule_tac id_leq_use_env)*)
    (* prove r_s3 - (rx1 + rx2) was cancellable *)
      apply (rule_tac mini_disj_comp_use_env)
       apply (rule_tac mini_disj_diff_use_env)
      apply (rule_tac r_s="r_s3" in mini_disj_leq_use_env2)
       apply (rule_tac gen_mini_disj_use_env2)
       apply (rule_tac infl_disj_use_env)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
    (* start perm expansion *)
     apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
         apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
          apply (rule_tac well_typed_perm_leq)
          apply (simp_all)
        apply (rule_tac self_comp_leq_use_env1)
       apply (cut_tac r_s="rx2" and r_x="infl_use_env r_s2 r_s3" and r="r" in lift_comp_use_env)
       apply (simp)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
         apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
          apply (rule_tac well_typed_perm_leq)
          apply (simp_all)
        apply (rule_tac self_comp_leq_use_env2)
       apply (simp add: infl_lift_use_env)(*
       apply (cut_tac ?r_s1.0="r_s2" and ?r_s2.0="r_s3" and r="r" in lift_refl_use_env)
       apply (auto)*)
       apply (rule_tac self_infl_leq_use_env)(*
       apply (rule_tac refl_leq_use_env)*)
      apply (rule_tac self_infl_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    (* end perms expansion *)
    apply (rule_tac comp_leq_use_env2)
    apply (cut_tac r_s="rx2" and r_x="infl_use_env r_s2 r_s3" and r="r" in lift_comp_use_env)
    apply (simp)
    apply (rule_tac rhs_unroll_dcl_use_env)
    apply (rule_tac rhs_unroll_dcl_use_env)
    apply (rule_tac disj_diff_leq_use_env)
     apply (simp add: infl_lift_use_env)
(*
     apply (cut_tac ?r_s1.0="r_s2" and ?r_s2.0="r_s3" and r="r" in lift_refl_use_env)
     apply (auto)*)
     apply (rule_tac comm_disj_use_env)
     apply (rule_tac infl_disj_use_env)
     apply (rule_tac self_diff_leq_use_env)
    apply (rule_tac rhs_fold_dcl_use_env)
    apply (rule_tac id_leq_use_env)
    (*apply (rule_tac comp_leq_use_env2)
    apply (rule_tac lhs_flip_use_env)
    apply (rule_tac rhs_flip_use_env)
    apply (rule_tac unroll_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    (* r_s3 - lift rx' \<ge> r_s3 - lift rx' - r_ex = (r_s3 - r_ex) - (lift rx' - r_ex) \<ge> (r_s3 - r_ex) - lift (rx' - r_ex) *)
    apply (rule_tac r_sb="diff_use_env (diff_use_env r_s3 (lift_use_env rx' r)) r_ex" in trans_leq_use_env)
     apply (rule_tac self_diff_leq_use_env)
    apply (cut_tac r_s="r_s3" and r_x="lift_use_env rx' r" and r_ex="r_ex" in dist_sq_diff_use_env)
    apply (simp)
    apply (rule_tac t="diff_use_env (lift_use_env rx' r) r_ex" and s="lift_use_env (diff_use_env rx' r_ex) r" in subst)
     apply (rule_tac outer_lift_diff_use_env)
    (* (r_s3 - r_ex) - lift (rx' - r_ex) = (r_s3 - lift (rx' - r_ex)) - r_ex \<ge> r_s3 - lift (rx' - r_ex), by semi-disjointness *)
    apply (rule_tac rhs_fold_dcl_use_env)
    apply (rule_tac rhs_flip_use_env)
    apply (rule_tac rhs_unroll_dcl_use_env)
    apply (rule_tac mini_disj_diff_leq_use_env)
    (* r_s3 - lift (rx' - r_ex) \<ge> r_s3 - lift rx2 *)
    apply (rule_tac dist_diff_leq_use_env_gen)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac dist_lift_leq_use_env)
     apply (simp)
    apply (rule_tac r_s="r_s3" in mini_disj_leq_use_env2)
     apply (auto)
    apply (rule_tac self_diff_leq_use_env)*)
    (* end perm / req ordering *)
   apply (rule_tac dist_diff_leq_use_env)
   apply (simp)
    (* req reduction *)
  apply (rule_tac dist_diff_leq_use_env_gen)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac r="r" in rem_add_leq_use_env)
    apply (auto)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac dist_lift_leq_use_env_gen)
   apply (cut_tac r_x="r_xe" and r_s="add_use_env rx1 (Var x) r" and x="Var x" in spec_leq_perm)
    apply (simp)
   apply (simp add: add_use_env_def)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac self_comp_leq_use_env1)
  apply (rule_tac comp_leq_use_env2)
  apply (rule_tac dist_lift_leq_use_env)
  apply (rule_tac self_comp_leq_use_env1)
  done
    
  
lemma subst_exp_fv_none: "\<lbrakk> x \<notin> free_vars e \<rbrakk> \<Longrightarrow> x \<notin> free_vars (subst_exp e x e')"    
  apply (induct e)
        apply (auto)
  apply (case_tac xa)
   apply (auto)
  done



    
  
lemma sstp_add_perms: "\<lbrakk> well_typed env delta (add_use_env r_s1 x r) e tau r_s2 rx;
  x \<notin> non_prim_vars env delta e \<rbrakk> \<Longrightarrow> well_typed env delta r_s1 e tau (rem_use_env r_s2 x) (rem_use_env rx x)"
  (* - it's easy to add removals. from there we can simply upgrade r_s1 *)
  apply (rule_tac ?r_s1.0="rem_use_env (add_use_env r_s1 x r) x" in well_typed_incr_start_perm)
   apply (rule_tac well_typed_rem_perms)
    apply (auto)
  apply (rule_tac t="rem_use_env (add_use_env r_s1 x r) x" and s="rem_use_env r_s1 x" in subst)
   apply (rule_tac partial_rem_add_use_env)
  apply (rule_tac self_rem_leq_use_env)
  done

    (*
        the intention of this lemma is to lift the regular subst_exp lemma to safe_subst_exp.
        the main difficulty is proving that the given end_perm / req bounds hold even in the non-substitution case,
        since the bounds for e1 are arbitrary. we can prove the bounds through the use of the lbound lemma + decr bound / incr req
    *)
lemma safe_subst_type_preserve_x: "\<lbrakk> well_typed (add_env env (Var x) t) delta (add_use_env rx1 (Var x) r) e1 tau r_s' r_end; safe_subst_exp e1 x e' e2;
  is_sexp e'; well_typed env delta r_s2 e' t r_s3 rx2; well_formed_delta env delta; leq_use_env r_s2 r_s1; leq_use_env rx1 r_s1;
  leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s3; (*safe_use_lift rx2 r; safe_type t r;*) disj_use_env rx1 (lift_use_env rx2 r) \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 e2 tau (diff_use_env r_s3 (comp_use_env rx1 (lift_use_env rx2 r)))
    (diff_use_env (comp_use_env rx1 rx2) (comp_use_env rx1 (lift_use_env rx2 r)))"    
  apply (simp add: safe_subst_exp_def)
  apply (auto)
  apply (case_tac "x \<in> free_vars e1")
   apply (rule_tac ?r_s2.0="diff_use_env r_s3 (comp_use_env (rem_use_env rx1 (Var x)) (lift_use_env rx2 r))" and
        rx="diff_use_env (comp_use_env (rem_use_env rx1 (Var x)) rx2) (comp_use_env (rem_use_env rx1 (Var x)) (lift_use_env rx2 r))" in well_typed_simul_end_perm)
    thm subst_type_preserve_app
        apply (rule_tac subst_type_preserve_app)
                    apply (auto)
                apply (cut_tac r_s="rx1" and x="Var x" and r="r" in partial_add_rem_use_env)
                apply (auto)
                apply (rule_tac lam_var_list_remove_type_preserve)
                   apply (auto)
               apply (simp add: rem_use_env_def)
              apply (rule_tac lam_var_list_remove_free_var_some)
               apply (auto)(*
             apply (cut_tac x="x" and vl="vl" and e="e1" in lam_var_list_remove_ref_var)
                 apply (auto)
             apply (simp add: disj_vars_def)
             apply (auto)*)
    (* show that for any x \<in> lam_vars e', x \<notin> lam_vars (replacing vl in e1). the idea is that if x \<in> lam_vars (replacing vl in e1), either
      x \<in> lam_vars e1 originally, in which case it would be in the pre_vars of vl + not in post_vars of vl, which would be broke. or else we
      must have x \<in> post_vars vl, also a contradiction.
    *)
            apply (case_tac "xa \<in> lam_vars e1")
             apply (cut_tac x="xa" and e="e1" and vl="vl" in lam_var_list_remove_lam_var_none2)
               apply (auto)
            apply (case_tac "xa \<notin> post_vars vl")
             apply (cut_tac x="xa" and e="e1" and vl="vl" in lam_var_list_remove_lam_var_none1)
               apply (auto)
      (* same idea, since we rename *)(*
           apply (case_tac "xa \<in> lam_vars e1")
            apply (cut_tac x="xa" and e="e1" and vl="vl" in lam_var_list_remove_lam_var_none2)
              apply (auto)
           apply (case_tac "xa \<notin> post_vars vl")
            apply (cut_tac x="xa" and e="e1" and vl="vl" in lam_var_list_remove_lam_var_none1)
               apply (auto)*)
    (* prove removing from rx1 is acceptable *)
          apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
           apply (simp)
          apply (rule_tac dist_comp_leq_use_env)
           apply (rule_tac comp_leq_use_env1)
           apply (rule_tac self_rem_leq_use_env)
          apply (rule_tac self_comp_leq_use_env2)
         apply (rule_tac r_s="rx1" in disj_leq_use_env1)
          apply (simp)
         apply (rule_tac self_rem_leq_use_env)
        apply (rule_tac rem_leq_use_env)
        apply (simp)
      (* - prove initial change of rx1 was valid *)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac self_rem_leq_use_env)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac self_comp_leq_use_env1)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac self_lift_leq_use_env)
     apply (rule_tac unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac lhs_dist_dcl_use_env)
     apply (rule_tac rhs_dist_dcl_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac t="diff_use_env (rem_use_env rx1 (Var x)) (rem_use_env rx1 (Var x))" and
        s="rem_use_env (diff_use_env rx1 rx1) (Var x)" in subst)
       apply (rule_tac dist_diff_rem_use_env)
      apply (rule_tac self_rem_leq_use_env)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac mini_disj_diff_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (cut_tac r_s="rx1" and r_x="rx2" and r="r" in disj_lift_use_envr)
      apply (simp)
     apply (simp add: disj_use_env_def)
      (* no fv case, starts by perm manipulation to use the lbound lemma
        - the idea behind the lbound lemma is that it gives us end perms + reqs to shoot for.
        - our end perm bound is > than the target, so we use the comp perms lemma to remove perms.
      *)
    apply (rule_tac ?r_s1.0="comp_use_env rx1 (diff_use_env r_s3 rx1)" in well_typed_incr_start_perm)
     apply (rule_tac ?r_s2.0="comp_use_env (diff_use_env rx1 rx1) (diff_use_env r_s3 rx1)" and
       rx="diff_use_env (rem_use_env r_end (Var x)) rx1" in well_typed_simul_end_perm)
        apply (rule_tac well_typed_comp_perms_gen)
         apply (rule_tac ?r_s2.0="rem_use_env r_s' (Var x)" in well_typed_end_perm_lbound)
         apply (rule_tac r="r" in sstp_add_perms)
          apply (auto)
    (* - now we apply the standard no fv lemma *)
          apply (rule_tac x="x" and t="t" in well_typed_add_vars_rev)
            apply (rule_tac subst_type_preserve_no_fv)
    (* - lastly we have to apply the lam var list lemma *)
             apply (rule_tac lam_var_list_remove_type_preserve)
               apply (auto)
            apply (cut_tac x="x" and e="e1" and vl="vl" in lam_var_list_remove_free_var_none)
             apply (auto)
           apply (cut_tac x="x" and e="e1" and vl="vl" in lam_var_list_remove_free_var_none)
            apply (auto)
           apply (cut_tac e="lam_var_list_remove e1 vl" and x="x" in  subst_exp_fv_none)
            apply (auto)(*
          apply (cut_tac e="e1" and vl="vl" and x="x" in lam_var_list_remove_ref_var)
              apply (auto)
           apply (simp add: disj_vars_def)
           apply (auto)
         apply (cut_tac x="x" and e="e1" and vl="vl" in lam_var_list_remove_free_var_none)
          apply (auto)*)
(*
          apply (cut_tac e="lam_var_list_remove e1 vl" and x="x" in no_subst_ref_vars)
            apply (auto)*)
         apply (cut_tac x="x" and e="e1" and vl="vl" in lam_var_list_remove_free_var_none)
          apply (auto)
         apply (cut_tac e="lam_var_list_remove e1 vl" and x="x" and e'="e'" in subst_exp_fv_none)
          apply (auto)
         apply (simp add: non_prim_vars_def)
         apply (cut_tac x="x" and e="subst_exp (lam_var_list_remove e1 vl) x e'" in free_res_vars)
          apply (auto)
      (* - now we have to prove the validity of our bound changes *)
        apply (rule_tac mini_disj_diff_use_env)
       apply (rule_tac comp_leq_use_env2)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac self_comp_leq_use_env1)
      apply (rule_tac dist_diff_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac self_comp_leq_use_env1)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac self_lift_leq_use_env)
     apply (rule_tac rhs_flip_use_env)
     apply (rule_tac rhs_unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac r_sb="rx1" in trans_leq_use_env)
      apply (rule_tac disj_diff_leq_use_env)
       apply (rule_tac comm_disj_use_env)
       apply (simp)
      apply (rule_tac self_comp_leq_use_env1)
     apply (rule_tac r="r" in rem_add_leq_use_env)
     apply (rule_tac r_sb="r_s'" in trans_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
     apply (rule_tac well_typed_perm_leqx)
     apply (auto)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
      apply (simp)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac self_diff_leq_use_env)
    done

end