theory AltDropEnv
  imports WTLemma
begin
  
    
definition well_formed_delta :: "pt_env \<Rightarrow> owner_env \<Rightarrow> bool" where
  "well_formed_delta env delta = (\<forall> x. (case env (Loc x) of
    None \<Rightarrow> True
    | Some tau \<Rightarrow> (\<exists> tau_x. env (Loc (delta x)) = Some tau_x \<and> req_type tau_x \<noteq> Aff \<and> req_type tau \<noteq> Prim)
  ))"
  
    (* - requirements dropping (reduces requirements to pass into lambdas) *)
    
definition drop_use_env where
  "drop_use_env r_s = (\<lambda> x. if r_s x = OwnPerm then UsePerm else r_s x)"    

lemma self_drop_leq_use_env: "leq_use_env (drop_use_env r_x) r_x"  
  apply (simp add: leq_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (auto)
  apply (case_tac "r_x x")
    apply (auto)
  done
    
lemma drop_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env (drop_use_env r_x) r_s"    
  apply (rule_tac r_sb="r_x" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac self_drop_leq_use_env)
  done  
    
lemma dist_drop_leq_use_env: "\<lbrakk> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env (drop_use_env r_x) (drop_use_env r_s)"    
  apply (simp add: leq_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (simp add: drop_use_env_def)
  apply (auto)
   apply (case_tac "r_s x")
     apply (auto)
  apply (case_tac "r_x x")
    apply (auto)
  done    
  
lemma weak_drop_use_env: "\<lbrakk> weak_use_env r_s \<rbrakk> \<Longrightarrow> drop_use_env r_s = r_s"
  apply (case_tac "\<forall> x. drop_use_env r_s x = r_s x")
   apply (auto)
  apply (simp add: drop_use_env_def)
  apply (simp add: weak_use_env_def)
  done    
    
lemma drop_weak_use_env: "weak_use_env (drop_use_env r_s)"    
  apply (simp add: weak_use_env_def)
  apply (simp add: drop_use_env_def)
  done    

lemma dist_drop_comp_use_env: "drop_use_env (comp_use_env r_sa r_sb) = comp_use_env (drop_use_env r_sa) (drop_use_env r_sb)"    
  apply (case_tac "\<forall> x. drop_use_env (comp_use_env r_sa r_sb) x = comp_use_env (drop_use_env r_sa) (drop_use_env r_sb) x")
   apply (auto)
  apply (simp add: comp_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (case_tac "r_sa x")
    apply (auto)
    apply (case_tac "r_sb x")
      apply (auto)
   apply (case_tac "r_sb x")
     apply (auto)
  apply (case_tac "r_sb x")
    apply (auto)
  done
    
lemma dom_lift_comp_use_env: "\<lbrakk> r = OwnPerm \<rbrakk> \<Longrightarrow> comp_use_env r_s (lift_use_env r_s r) = comp_use_env (drop_use_env r_s) (lift_use_env r_s r)"    
  apply (case_tac "\<forall> x. comp_use_env r_s (lift_use_env r_s r) x = comp_use_env (drop_use_env r_s) (lift_use_env r_s r) x")
   apply (auto)
  apply (simp add: comp_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (case_tac "r_s x")
    apply (auto)
  done    
    
lemma drop_lift_leq_use_env: "leq_use_env (drop_use_env (lift_use_env r_s r)) (lift_use_env (drop_use_env r_s) r)"    
  apply (simp add: drop_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (auto)
   apply (case_tac r)
     apply (auto)
  apply (case_tac r)
    apply (auto)
   apply (case_tac "r_s x")
     apply (auto)
  apply (case_tac "r_s x")
    apply (auto)
  done

lemma rhs_drop_leq_use_env: "\<lbrakk> weak_use_env r_x; leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> leq_use_env r_x (drop_use_env r_s)"    
  apply (simp add: weak_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (case_tac "r_x x")
    apply (auto)
  done     
    
lemma diff_drop_use_env: "drop_use_env (diff_use_env r_s r_ex) = diff_use_env (drop_use_env r_s) r_ex"
  apply (case_tac "\<forall> x. drop_use_env (diff_use_env r_s r_ex) x = diff_use_env (drop_use_env r_s) r_ex x")
   apply (auto)
  apply (simp add: diff_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (case_tac "r_ex x")
    apply (auto)
   apply (case_tac "r_s x")
     apply (auto)
  apply (case_tac "r_s x")
    apply (auto)
  done  
  

lemma dist_drop_diff_use_env: "diff_use_env (drop_use_env r_s) r_x = drop_use_env (diff_use_env r_s r_x)"    
  apply (case_tac "\<forall> x. diff_use_env (drop_use_env r_s) r_x x = drop_use_env (diff_use_env r_s r_x) x")
   apply (auto)
  apply (simp add: diff_use_env_def)
  apply (simp add: drop_use_env_def)
  apply (case_tac "r_s x = OwnPerm")
   apply (auto)
   apply (case_tac "r_x x")
     apply (auto)
  apply (case_tac "r_x x")
    apply (auto)
  done
    

lemma self_diff_weak_use_env: "\<lbrakk> leq_use_env r_s (diff_use_env r_s r_x); leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> weak_use_env r_x"  
  apply (simp add: leq_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (simp add: weak_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (case_tac "r_s x")
    apply (auto)
  done    
    
    (* this lemma states that if an expression is a non-affine s-expression, it can be typed without affine permissions.
        this is one of the main reasons that 
    *)
lemma wt_sexp_drop_all: "\<lbrakk> well_typed env delta rx e tau rx rx'; well_formed_delta env delta; req_type tau \<noteq> Aff; is_sexp e \<rbrakk> \<Longrightarrow>
  well_typed env delta (drop_use_env rx) e tau (drop_use_env rx) (drop_use_env rx')"
  apply (induct e arbitrary: env tau rx rx')
        apply (auto)
    (* const + op cases *)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac dist_drop_leq_use_env)
         apply (simp)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (simp)
    (* var case p1.
        - say that x was non-affine, but was owned by an affine data structure. in this case, the permissions we receive cannot be reduced.
     *)
      apply (rule_tac ereq_leq_use_envx)
      apply (cut_tac r_x="ereq_use_env (owner_name delta x) tau_x" and r_s="rx" and x="owner_name delta x" in spec_leq_perm)
       apply (simp)
      apply (simp add: ereq_use_env_def)
      apply (simp add: one_use_env_def)
      apply (simp add: drop_use_env_def)
      apply (simp add: end_req_perm_def)
      apply (case_tac x)
       apply (auto)
      apply (simp add: well_formed_delta_def)
      apply (erule_tac x="x2" in allE)
      apply (case_tac "req_type tau_x")
        apply (auto)
    (* var case p2 *)
     apply (cut_tac r_s="rx" and r_x="comp_use_env (ereq_use_env (owner_name delta x) tau_x) r_ex" in self_diff_weak_use_env)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (auto)
     apply (rule_tac x="r_ex" in exI)
     apply (auto)
        apply (rule_tac rhs_weak_leq_use_env)
         apply (case_tac tau)
               apply (auto)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (simp)
      apply (rule_tac rhs_drop_leq_use_env)
       apply (rule_tac r_sa="ereq_use_env (owner_name delta x) tau_x" in weak_comp_use_env2)
       apply (auto)
     apply (rule_tac rhs_drop_leq_use_env)
      apply (rule_tac weak_diff_use_env)
      apply (rule_tac r_sb="r_ex" in weak_comp_use_env1)
      apply (case_tac tau)
            apply (auto)
    (* pair case *)
    apply (case_tac "r = OwnPerm")
     apply (auto)
    apply (case_tac "max_aff (req_type t1) (req_type t2) = Aff")
     apply (case_tac r)
       apply (auto)
    apply (case_tac "req_type t1 = Aff")
     apply (auto)
    apply (case_tac "req_type t2 = Aff")
      apply (case_tac "req_type t1")
       apply (auto)
    apply (case_tac "lift_use_env rx2 r \<noteq> rx2 \<or> lift_use_env rx1 r \<noteq> rx1")
     apply (case_tac r)
       apply (auto)
(*
    apply (case_tac "\<not> (req_type t1 \<noteq> Aff \<and> req_type t2 \<noteq> Aff)")
     apply (auto)
     apply (case_tac "req_type t1")
       apply (auto)*)
    apply (cut_tac r_s="rx" and r_x="r_ex" in self_diff_weak_use_env)
      apply (rule_tac r_sb="diff_use_env r_s3 r_ex" in trans_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
        apply (rule_tac well_typed_perm_leq)
        apply (auto)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac x="drop_use_env rx" in exI)
    apply (rule_tac x="drop_use_env rx" in exI)
    apply (rule_tac x="drop_use_env rx1" in exI)
    apply (auto)
     apply (cut_tac e="e1" in value_is_sexp)
      apply (auto)
     apply (cut_tac env="env" and ?r_s1.0="rx" and r_c="r_s2" and ?r_s2.0="rx" and e="e1" and tau="t1" and rx="rx1" in well_typed_decr_end_perm)
        apply (auto)
      apply (rule_tac r_sb="diff_use_env r_s3 r_ex" in trans_leq_use_env)
       apply (rule_tac diff_leq_use_env)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
     apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
     apply (rule_tac well_typed_perm_leqx)
     apply (auto)
    apply (cut_tac r_sc="r_s3" and r_sb="r_s2" and r_sa="rx" in trans_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (cut_tac r_sc="rx" and r_sb="diff_use_env r_s3 r_ex" and r_sa="r_s3" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (simp)
    apply (case_tac "lift_use_env (drop_use_env rx2) r \<noteq> drop_use_env rx2")
     apply (case_tac r)
       apply (auto)
    apply (case_tac "lift_use_env (drop_use_env rx1) r \<noteq> drop_use_env rx1")
     apply (case_tac r)
       apply (auto)
    apply (rule_tac x="drop_use_env rx2" in exI)
    apply (auto)
          apply (cut_tac e="e2" in value_is_sexp)
           apply (auto)
          apply (cut_tac env="env" and ?r_s1.0="rx" and r_c="r_s3" and ?r_s2.0="rx" and e="e2" and tau="t2" and rx="rx2" in well_typed_decr_end_perm)
             apply (rule_tac ?r_s1.0="r_s2" in well_typed_incr_start_perm)
              apply (auto)
           apply (rule_tac well_typed_perm_leq)
           apply (auto)
          apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
         apply (auto)
         apply (rule_tac dist_drop_leq_use_env)
         apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
          apply (auto)
        apply (rule_tac dist_drop_leq_use_env)
        apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
         apply (auto)
     apply (rule_tac r_s="rx1" in disj_leq_use_env1)
      apply (rule_tac r_s="rx2" in disj_leq_use_env2)
       apply (simp)
      apply (rule_tac self_drop_leq_use_env)
     apply (rule_tac self_drop_leq_use_env)
    apply (rule_tac x="empty_use_env" in exI)
    apply (auto)
       apply (rule_tac rhs_weak_leq_use_env)
        apply (simp add: weak_use_env_def)
        apply (simp add: empty_use_env_def)
       apply (rule_tac id_leq_use_env)
      apply (rule_tac dist_drop_leq_use_env)
      apply (simp)
     apply (rule_tac leq_empty_use_env)
    apply (case_tac "req_type (PairTy t1 t2 r) = Prim")
     apply (simp add: pair_req_def)
     apply (rule_tac leq_empty_use_env)
    apply (simp add: pair_req_def)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac r_sb="drop_use_env (diff_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
     apply (rule_tac dist_drop_leq_use_env)
     apply (simp)
    apply (rule_tac t="drop_use_env (diff_use_env (comp_use_env rx1 rx2) r_ex)" and s="diff_use_env (drop_use_env (comp_use_env rx1 rx2)) r_ex" in subst)
     apply (rule_tac dist_drop_diff_use_env)
    apply (rule_tac rhs_weak_leq_use_env)
     apply (simp)
    apply (simp add: dist_drop_comp_use_env)
    apply (rule_tac id_leq_use_env)
    (* lam case *)
   apply (simp add: aff_use_env_def)
   apply (rule_tac x="rxa" in exI)
   apply (auto)
    apply (rule_tac rhs_drop_leq_use_env)
     apply (auto)
    apply (case_tac a)
      apply (auto)
    apply (simp add: weak_use_env_def)
    apply (simp add: null_use_env_def)
   apply (cut_tac r_s="rx" and r_x="r_ex" in self_diff_weak_use_env)
     apply (auto)
   apply (rule_tac x="r_ex" in exI)
   apply (auto)
      apply (rule_tac rhs_weak_leq_use_env)
       apply (simp)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac dist_drop_leq_use_env)
     apply (simp)
    apply (rule_tac rhs_drop_leq_use_env)
     apply (auto)
   apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac weak_diff_use_env)
    apply (auto)
   apply (case_tac a)
     apply (auto)
   apply (simp add: weak_use_env_def)
   apply (simp add: null_use_env_def)
    (* app case. e1 *)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="drop_use_env rx" in exI)
  apply (rule_tac x="empty_use_env" in exI)
  apply (auto)
   apply (case_tac e1)
         apply (auto)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac leq_empty_use_env)
    (* app case. e2, lambda unrolling *)
  apply (rule_tac x="drop_use_env rx2" in exI)
  apply (rule_tac x="drop_use_env rx" in exI)
  apply (auto)
   apply (cut_tac env="env" and r_c="rx" and ?r_s1.0="r_s2" and ?r_s2.0="rx" and e="e2" and tau="t1" and rx="rx2" in well_typed_incr_start_perm)
     apply (rule_tac r_c="r_s3" in well_typed_decr_end_perm)
       apply (simp)
      apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (rule_tac self_diff_leq_use_env)
      apply (simp)
     apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
      apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
     apply (rule_tac well_typed_perm_leqx)
     apply (auto)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
    (* - prove that e2 is an s-expression *)
   apply (case_tac "\<not> is_sexp e2")
    apply (cut_tac ?e1.0="e1" and ?e2.0="e2" in e2_sexp)
     apply (simp_all)
    (* - prove that t1 is unlim *)
   apply (case_tac "\<not> req_type t1 \<noteq> Aff")
    apply (case_tac e1)
         apply (auto)
    apply (case_tac x1)
               apply (auto)
        apply (simp_all add: pure_fun_def)
    (* app case. tau primitive case (only happens for fixed point w/ primitive fun) *)
  apply (simp add: app_req_def)
  apply (case_tac "req_type tau = Prim")
   apply (auto)
   apply (case_tac e1)
        apply (auto)
    apply (case_tac x1)
                apply (auto)
        apply (simp_all add: pure_fun_def)
   apply (auto)
   apply (case_tac t)
          apply (auto)
   apply (case_tac "\<not> weak_use_env empty_use_env")
    apply (simp add: weak_use_env_def)
    apply (simp add: empty_use_env_def)
   apply (rule_tac x="empty_use_env" in exI)
   apply (auto)
         apply (rule_tac rhs_weak_leq_use_env)
          apply (rule_tac dist_weak_comp_use_env)
           apply (rule_tac dist_weak_comp_use_env)
            apply (auto)
          apply (rule_tac drop_weak_use_env)
         apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac leq_empty_use_env)
       apply (rule_tac dist_drop_leq_use_env)
       apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac well_typed_perm_leq)
        apply (auto)
       apply (rule_tac well_typed_perm_leqx)
       apply (auto)
      apply (rule_tac disj_empty_use_env2)
     apply (rule_tac dist_drop_leq_use_env)
     apply (simp)
    apply (rule_tac leq_empty_use_env)
   apply (rule_tac leq_empty_use_env)
    (* non prim case. *)
    (* - prove weakness of rx1 + rx2 + r_ex *)
  apply (cut_tac r_s="r_s3" and r_x="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in self_diff_weak_use_env)
    apply (rule_tac r_sb="rx" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (rule_tac dist_comp_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="rx" in trans_leq_use_env)
    apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
     apply (rule_tac self_diff_leq_use_env)
    apply (simp_all)
    (* - r not ownership *)
  apply (case_tac "r = OwnPerm")
   apply (case_tac e1)
        apply (auto)
   apply (case_tac x1)
               apply (auto)
        apply (simp_all add: pure_fun_def)
    (* - final manipulation *)
  apply (rule_tac x="r_ex" in exI)
  apply (auto)
       apply (rule_tac rhs_weak_leq_use_env)
        apply (rule_tac r_s="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in leq_weak_use_env)
         apply (simp)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac comp_leq_use_env1)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac leq_empty_use_env)
         apply (rule_tac comp_leq_use_env2)
         apply (rule_tac dist_lift_leq_use_env)
         apply (rule_tac self_drop_leq_use_env)
        apply (rule_tac self_comp_leq_use_env2)
       apply (rule_tac id_leq_use_env)
(*
       apply (simp add: drop_use_env_def)
       apply (case_tac r)
         apply (auto)*)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac leq_empty_use_env)
      apply (case_tac "lift_use_env (drop_use_env rx2) r \<noteq> drop_use_env rx2")
       apply (case_tac r)
         apply (auto)
      apply (rule_tac dist_drop_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac r_sb="r_s2" in trans_leq_use_env)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac self_lift_leq_use_env)
     apply (rule_tac disj_empty_use_env2)
    apply (rule_tac dist_drop_leq_use_env)
    apply (simp)
   apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac r_sa="comp_use_env rx1 (lift_use_env rx2 r)" in weak_comp_use_env2)
    apply (auto)
  apply (rule_tac r_sb="drop_use_env (diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" in trans_leq_use_env)
   apply (rule_tac dist_drop_leq_use_env)
   apply (auto)
  apply (rule_tac rhs_drop_leq_use_env)
   apply (rule_tac weak_diff_use_env)
   apply (rule_tac dist_weak_comp_use_env)
    apply (simp add: weak_use_env_def)
    apply (simp add: empty_use_env_def)
   apply (rule_tac drop_weak_use_env)
  apply (rule_tac rhs_weak_leq_use_env)
   apply (simp)
  apply (rule_tac diff_leq_use_env)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac comp_leq_use_env2)
  apply (rule_tac self_drop_leq_use_env)
  done        
    
lemma wt_sexp_drop_req: "\<lbrakk> well_typed env delta r_s1 e tau r_s2 rx; well_formed_delta env delta; req_type tau \<noteq> Aff; (*\<not> aff_fun_ty tau;*) is_sexp e \<rbrakk> \<Longrightarrow>
    well_typed env delta r_s1 e tau r_s2 (drop_use_env rx)"
  apply (induct e arbitrary: r_s1 r_s2 tau rx)
        apply (auto)
    (* const + op cases *)
       apply (rule_tac drop_leq_use_env)
       apply (simp)
      apply (rule_tac drop_leq_use_env)
      apply (simp)
    (* var case. *)
     apply (rule_tac x="r_ex" in exI)
     apply (auto)
      apply (rule_tac drop_leq_use_env)
      apply (simp)
     apply (rule_tac rhs_drop_leq_use_env)
      apply (rule_tac weak_diff_use_env)
      apply (rule_tac weak_ereq_use_env)
      apply (simp add: unlim_def)
      apply (case_tac x)
       apply (auto)
     apply (simp add: well_formed_delta_def)
     apply (erule_tac x="x2" in allE)
     apply (auto)
    (* pair case. *)
    apply (case_tac "r = OwnPerm")
     apply (auto)
    apply (case_tac "max_aff (req_type t1) (req_type t2) = Aff")
     apply (case_tac r)
       apply (auto)
    apply (rule_tac x="r_s2a" in exI)
    apply (rule_tac x="r_s3" in exI)
    apply (rule_tac x="drop_use_env rx1" in exI)
    apply (auto)
     apply (case_tac "req_type t1 = Aff")
      apply (auto)
     apply (cut_tac e="e1" in value_is_sexp)
      apply (auto)
    apply (rule_tac x="drop_use_env rx2" in exI)
    apply (auto)
        apply (case_tac "req_type t2 = Aff")
         apply (case_tac "req_type t1")
           apply (auto)
        apply (cut_tac e="e2" in value_is_sexp)
         apply (auto)
       apply (rule_tac r_sb="lift_use_env rx1 r" in trans_leq_use_env)
        apply (simp)
       apply (rule_tac dist_lift_leq_use_env)
       apply (rule_tac self_drop_leq_use_env)
      apply (rule_tac r_sb="lift_use_env rx2 r" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac self_drop_leq_use_env)
     apply (rule_tac r_s="lift_use_env rx1 r" in disj_leq_use_env1)
      apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
       apply (simp)
      apply (rule_tac dist_lift_leq_use_env)
      apply (rule_tac self_drop_leq_use_env)
     apply (rule_tac dist_lift_leq_use_env)
     apply (rule_tac self_drop_leq_use_env)
    apply (rule_tac x="r_ex" in exI)
    apply (auto)
     apply (rule_tac drop_leq_use_env)
     apply (simp)
    apply (case_tac "lift_use_env (drop_use_env rx1) r \<noteq> drop_use_env rx1")
     apply (case_tac r)
       apply (auto)
    apply (case_tac "lift_use_env (drop_use_env rx2) r \<noteq> drop_use_env rx2")
     apply (case_tac r)
       apply (auto)
    apply (case_tac "req_type (PairTy t1 t2 r) = Prim")
     apply (simp add: pair_req_def)
     apply (rule_tac leq_empty_use_env)
    apply (simp add: pair_req_def)
    apply (rule_tac rhs_drop_leq_use_env)
     apply (rule_tac weak_diff_use_env)
     apply (rule_tac dist_weak_comp_use_env)
      apply (rule_tac drop_weak_use_env)
     apply (rule_tac drop_weak_use_env)
    apply (rule_tac r_sb="diff_use_env (comp_use_env (lift_use_env rx1 r) (lift_use_env rx2 r)) r_ex" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac drop_leq_use_env)
     apply (rule_tac self_lift_leq_use_env)
    apply (rule_tac comp_leq_use_env2)
    apply (rule_tac drop_leq_use_env)
    apply (rule_tac self_lift_leq_use_env)
    (* lam case  *)
   apply (rule_tac x="rxa" in exI)
   apply (auto)
   apply (rule_tac x="r_ex" in exI)
   apply (auto)
    apply (rule_tac drop_leq_use_env)
    apply (simp)
   apply (rule_tac rhs_drop_leq_use_env)
    apply (rule_tac weak_diff_use_env)
    apply (simp add: aff_use_env_def)
    apply (case_tac a)
      apply (auto)
   apply (simp add: null_use_env_def)
   apply (simp add: weak_use_env_def)
    (* app case *)
  apply (rule_tac x="t1" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="r_s2a" in exI)
  apply (rule_tac x="drop_use_env rx1" in exI)
  apply (auto)
   apply (case_tac "req_type (FunTy t1 tau r a) = Aff")
    apply (case_tac e1)
          apply (auto)
    apply (case_tac x1)
                apply (auto)
         apply (simp_all add: pure_fun_def)
   apply (case_tac "\<not> is_sexp e1")
    apply (case_tac e1)
          apply (auto)
  apply (rule_tac x="drop_use_env rx2" in exI)
  apply (rule_tac x="r_s3" in exI)
  apply (auto)
   apply (case_tac "req_type t1 = Aff")
    apply (case_tac e1)
          apply (auto)
    apply (case_tac x1)
                apply (auto)
         apply (simp_all add: pure_fun_def)
   apply (case_tac "\<not> is_sexp e2")
    apply (case_tac "is_value e2")
     apply (cut_tac e="e2" in value_is_sexp)
      apply (auto)
    apply (case_tac e1)
          apply (auto)
   apply (case_tac x1)
               apply (auto)
   apply (case_tac e2)
         apply (auto)
  apply (cut_tac r_xa="drop_use_env rx1" and r_xb="lift_use_env (drop_use_env rx2) r" and r_s="comp_use_env rx1 (lift_use_env rx2 r)" in dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac self_drop_leq_use_env)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac dist_lift_leq_use_env)
   apply (rule_tac self_drop_leq_use_env)
  apply (rule_tac x="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in exI)
  apply (auto)
      apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (rule_tac dist_diff_leq_use_env_gen)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
         apply (simp)
        apply (rule_tac id_leq_use_env)
       apply (simp)
     apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
      apply (simp_all)
    apply (rule_tac r_s="rx1" in disj_leq_use_env1)
     apply (rule_tac r_s="lift_use_env rx2 r" in disj_leq_use_env2)
      apply (simp)
     apply (rule_tac dist_lift_leq_use_env)
     apply (rule_tac self_drop_leq_use_env)
    apply (rule_tac self_drop_leq_use_env)
   apply (rule_tac drop_leq_use_env)
    apply (simp)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  apply (case_tac "req_type tau = Prim")
   apply (simp add: app_req_def)
   apply (rule_tac leq_empty_use_env)
  apply (simp add: app_req_def)
  apply (rule_tac rhs_drop_leq_use_env)
   apply (rule_tac weak_diff_use_env)
   apply (rule_tac dist_weak_comp_use_env)
    apply (rule_tac drop_weak_use_env)
   apply (rule_tac drop_weak_use_env)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac dist_diff_leq_use_env_gen)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac self_drop_leq_use_env)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac self_drop_leq_use_env)
  apply (rule_tac self_comp_leq_use_env2)
  done
    
    (* ####### primitive lemmas *)
    
    (* - we dont allow primitives to be contained in memory because this means a primitive may require permissions to access, breaking this lemma *)
lemma wt_sexp_no_all: "\<lbrakk> well_typed env delta r_s1 e tau r_s2 rx; well_formed_delta env delta; req_type tau = Prim; is_sexp e \<rbrakk> \<Longrightarrow>
  well_typed env delta empty_use_env e tau empty_use_env empty_use_env"     
  apply (induction e arbitrary: env tau r_s1 r_s2 rx)
        apply (auto)
    (* const + op case *)   
        apply (rule_tac leq_empty_use_env)
       apply (rule_tac leq_empty_use_env)
    (* var case *)
      apply (case_tac x)
       apply (auto)
      apply (rule_tac ereq_leq_use_envx)
      apply (simp add: end_req_perm_def)
      apply (simp add: empty_use_env_def)
      apply (simp add: well_formed_delta_def)
      apply (erule_tac x="x2" in allE)
      apply (auto)
     apply (rule_tac x="empty_use_env" in exI)
     apply (simp add: leq_empty_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (case_tac x)
      apply (auto)
     apply (rule_tac ereq_leq_use_envx)
     apply (simp add: end_req_perm_def)
     apply (simp add: empty_use_env_def)
     apply (simp add: well_formed_delta_def)
      apply (erule_tac x="x2" in allE)
     apply (auto)
    (* pair case *)
    apply (case_tac "r \<noteq> NoPerm")
     apply (case_tac r)
       apply (auto)
    apply (case_tac "max_aff (req_type t1) (req_type t2)")
      apply (auto)
    apply (case_tac "req_type t1")
       apply (auto)
     apply (case_tac "req_type t2")
       apply (auto)
    apply (case_tac "req_type t2")
      apply (auto)
    apply (rule_tac x="empty_use_env" in exI)
    apply (rule_tac x="empty_use_env" in exI)
    apply (rule_tac x="empty_use_env" in exI)
    apply (auto)
     apply (cut_tac e="e1" in value_is_sexp)
      apply (auto)
    apply (rule_tac x="empty_use_env" in exI)
    apply (auto)
        apply (cut_tac e="e2" in value_is_sexp)
         apply (auto)
      apply (rule_tac leq_empty_use_env)
     apply (rule_tac disj_empty_use_env1)
    apply (rule_tac x="empty_use_env" in exI)
    apply (auto)
      apply (rule_tac leq_empty_use_env)
     apply (rule_tac leq_empty_use_env)
    apply (simp add: pair_req_def)
    apply (rule_tac leq_empty_use_env)
    (* lam case *)
   apply (rule_tac x="rxa" in exI)
   apply (auto)
    apply (simp add: leq_use_env_def)
    apply (simp add: aff_use_env_def)
    apply (simp add: null_use_env_def)
   apply (rule_tac x="empty_use_env" in exI)
   apply (auto)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac leq_empty_use_env)
   apply (rule_tac diff_leq_use_env)
   apply (simp add: leq_use_env_def)
   apply (simp add: aff_use_env_def)
   apply (simp add: null_use_env_def)
    (* app case. since tau is primitive, the only possible const is the fix point *)
  apply (case_tac e1)
        apply (auto)
  apply (case_tac "x1 \<noteq> FixConst")
   apply (case_tac x1)
               apply (auto)
       apply (simp_all add: pure_fun_def)
    (* - with that in mind, we fill in the rest *)
  apply (auto)
  apply (rule_tac x="empty_use_env" in exI)
  apply (auto)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac x="empty_use_env" in exI)
  apply (auto)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac x="empty_use_env" in exI)
  apply (rule_tac x="empty_use_env" in exI)
  apply (auto)
   apply (case_tac "\<not> is_sexp e2")
    apply (case_tac e2)
          apply (auto)
  apply (rule_tac x="empty_use_env" in exI)
  apply (auto)
       apply (rule_tac leq_empty_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac leq_empty_use_env)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac disj_empty_use_env2)
   apply (rule_tac leq_empty_use_env)
  apply (simp add: app_req_def)
  apply (rule_tac leq_empty_use_env)
  done
    
lemma wt_sexp_no_req: "\<lbrakk> well_typed env delta r_s1 e tau r_s2 rx; well_formed_delta env delta; req_type tau = Prim; is_sexp e \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 e tau r_s2 empty_use_env"     
  apply (rule_tac r_c="r_s1" in well_typed_decr_end_perm)
    apply (rule_tac r_s="empty_use_env" in well_typed_incr_simul_perm)
     apply (rule_tac leq_empty_use_env)
    apply (rule_tac wt_sexp_no_all)
      apply (auto)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  apply (rule_tac leq_empty_use_env)
  done       
    
    
fun drop_use_env_dep where
  "drop_use_env_dep r_s OwnPerm = r_s"
| "drop_use_env_dep r_s UsePerm = drop_use_env r_s"
| "drop_use_env_dep r_s NoPerm = empty_use_env"    
  
lemma wt_sexp_drop_dep_req: "\<lbrakk> well_typed env delta r_s1 e tau r_s2 rx; well_formed_delta env delta; is_sexp e; safe_type_x tau r \<rbrakk> \<Longrightarrow> well_typed env delta r_s1 e tau r_s2 (drop_use_env_dep rx r)"  
  apply (case_tac r)
    apply (auto)
   apply (rule_tac wt_sexp_no_req)
     apply (auto)
  apply (rule_tac wt_sexp_drop_req)
    apply (auto)
  apply (simp add: unlim_def)
  done
    
end