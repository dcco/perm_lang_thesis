theory RedSafeCV
  imports RedSafeUnpack
begin
  
    (* ##### array extension case ###### *)
  (*
definition ext_arr_abbrev where
  "ext_arr_abbrev v = AppExp (ConstExp ExtArrayConst) (VarExp v)"  *)
  
definition var_abbrev where
  "var_abbrev v = VarExp v"  
  (*
definition ext_app_abbrev where
  "ext_app_abbrev a v = AppExp (ext_arr_abbrev a) v"  
  
lemma ext_arr_type: "\<lbrakk> well_typed env delta r_s1 (ext_arr_abbrev v) tau r_s2 rx; well_formed_delta env delta; v = LocType x \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 (ext_arr_abbrev v) tau r_s1 (comp_use_env rx (infl_use_env r_s1 r_s2))"
  apply (rule_tac infl_full_sexp_wp)
   apply (simp_all)
  apply (simp add: ext_arr_abbrev_def)
  done 
  
lemma ext_var_type: "\<lbrakk> well_typed env delta r_s1 (ext_arr_abbrev v) (FunTy t1 t2 r a) r_s1 (comp_use_env rx (infl_use_env r_s1 r_s2)) \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 (var_abbrev v) t2 r_s1 (comp_use_env rx (infl_use_env r_s1 r_s2))"
  apply (simp add: var_abbrev_def)
  apply (simp add: ext_arr_abbrev_def)
  apply (auto)
     apply (simp add: pure_fun_def)
    apply (simp add: pure_fun_def)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (auto)
  apply (rule_tac x="r_ex" in exI)
  apply (auto)
    apply (rule_tac mini_disj_diff_leq_use_env2)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac r_s="diff_use_env r_s2a (comp_use_env (ereq_use_env (owner_name delta v) tau_x) r_ex)" in mini_disj_leq_use_env2)
     apply (rule_tac mini_disj_diff_use_env)
    apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 ra)) r_exa)" in trans_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (auto)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (auto)
  apply (simp add: pure_fun_def)
  apply (auto)
  apply (simp add: app_req_def)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 rx2) r_exa)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac mini_disj_diff_leq_use_env2)
   apply (rule_tac comp_leq_use_env2)
   apply (simp)
  apply (rule_tac r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 rx2) r_exa)" in mini_disj_leq_use_env2)
   apply (rule_tac mini_disj_diff_use_env)
  apply (rule_tac r_sb="comp_use_env rx1 rx2" in trans_leq_use_env)
   apply (rule_tac r_sb="r_s1" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
    apply (rule_tac r_sb="diff_use_env r_s2a (comp_use_env (ereq_use_env (owner_name delta v) tau_x) r_ex)" in trans_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (auto)
  apply (rule_tac comp_leq_use_env2)
  apply (simp)
  done
    
lemma ext_var_type2: "\<lbrakk> well_typed env delta r_s1 (ext_arr_abbrev v) (FunTy t1 t2 r a) r_s2 rx \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 (var_abbrev v) t2 r_s2 rx"    
  apply (simp add: ext_arr_abbrev_def)
  apply (simp add: var_abbrev_def)
  apply (auto)
     apply (simp add: pure_fun_def)
    apply (simp add: pure_fun_def)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (auto)
  apply (rule_tac x="comp_use_env r_ex (comp_use_env (comp_use_env rx1 (lift_use_env rx2 ra)) r_exa)" in exI)
  apply (auto)
    apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 ra)) r_exa)" in trans_leq_use_env)
     apply (rule_tac rhs_unroll_dcl_use_env)
     apply (rule_tac rhs_unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac rhs_fold_dcl_use_env)
    apply (rule_tac r_sb="diff_use_env r_s2a (comp_use_env (ereq_use_env (owner_name delta v) tau_x) r_ex)" in trans_leq_use_env)
     apply (rule_tac dist_diff_leq_use_env)
      apply (auto)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
     apply (auto)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac r_sb="diff_use_env r_s2a (comp_use_env (ereq_use_env (owner_name delta v) tau_x) r_ex)" in trans_leq_use_env)
      apply (rule_tac diff_leq_use_env)
      apply (auto)
  apply (simp add: app_req_def)
  apply (simp add: pure_fun_def)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 rx2) r_exa)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac lhs_fold_dcl_use_env)
  apply (rule_tac comp_leq_use_env2)
  apply (simp)
  done
   
lemma ext_var_loc_none: "\<lbrakk> well_typed env delta r_s1 (var_abbrev (LocType v)) tau r_s2 rx; env (Loc (delta v)) = Some tau_x; req_type tau_x = Ref;
  well_formed_delta env delta \<rbrakk> \<Longrightarrow> comp_use_env rx (infl_use_env r_s1 r_s2) (Loc (delta v)) \<noteq> NoPerm"    
  apply (simp add: var_abbrev_def)
  apply (auto)
  apply (cut_tac r_sa="rx" and r_sb="infl_use_env r_s1 r_s2" and x="Loc (delta v)" in comp_use_none_both)
   apply (auto)
  apply (cut_tac r_x="diff_use_env (ereq_use_env (Loc (delta v)) tau_x) (comp_use_env (ereq_use_env (Loc (delta v)) tau_x) r_ex)" and r_s="rx" and x="Loc (delta v)" in leq_use_none)
    apply (auto)
  apply (cut_tac r_s="ereq_use_env (Loc (delta v)) tau_x" and r_x="comp_use_env (ereq_use_env (Loc (delta v)) tau_x) r_ex" and x="Loc (delta v)" in diff_use_eq)
   apply (auto)
   apply (case_tac "cut_use_env (comp_use_env (ereq_use_env (Loc (delta v)) tau_x) r_ex) (Loc (delta v)) \<noteq> OwnPerm")
    apply (simp add: cut_use_env_def)
   apply (cut_tac r_s="infl_use_env r_s1 r_s2" and r_x="cut_use_env (comp_use_env (ereq_use_env (Loc (delta v)) tau_x) r_ex)" and x="Loc (delta v)" in leq_use_own)
     apply (auto)
   apply (rule_tac infl_leq_use_env)
    apply (simp)
   apply (rule_tac dist_comp_leq_use_env)
    apply (simp_all)
  apply (simp add: ereq_use_env_def)
  apply (simp add: one_use_env_def)
  apply (simp add: end_req_perm_def)
  done *)
    
lemma spec_disj_diff_perms: "\<lbrakk> well_typed env delta r_s1 e tau r_s2 rx; well_formed_delta env delta; is_sexp e;
  disj_use_env rx1 rx2; well_typed env delta r_s1 e tau r_s1 rx1 \<rbrakk> \<Longrightarrow>
  well_typed env delta (diff_use_env r_s1 rx2) e tau (diff_use_env r_s2 rx2) (diff_use_env rx rx2)"  
  apply (rule_tac well_typed_diff_perms)
   apply (simp)
  apply (auto)
  apply (case_tac "r_s1 x \<noteq> NoPerm")
   apply (cut_tac ?r_s1.0="r_s1" and ?r_s2.0="r_s1" and rx="rx1" in wt_sexp_req_use)
       apply (auto)
   apply (simp add: disj_use_env_def)
   apply (simp add: own_env_vars_def)
   apply (simp add: mini_disj_use_env_def)
  apply (cut_tac x="x" and ?r_s1.0="r_s1" and env="env" and e="e" in well_typed_no_npv_use)
    apply (auto)
  done
   
lemma sub_sep_nres_map: "\<lbrakk> contain_env rs_map rs_map'; sep_nres_map r_s rs_map \<rbrakk> \<Longrightarrow> sep_nres_map r_s rs_map'"     
  apply (simp add: sep_nres_map_def)
  apply (auto)
  apply (simp add: contain_env_def)
  apply (erule_tac x="x" in allE)
  apply (simp add: nres_lookup_def)
  apply (case_tac "rs_map' x")
   apply (auto)
   apply (rule_tac empty_strong_disj_use_env2)
  apply (erule_tac x="x" in allE)
  apply (auto)
  done
  
lemma simp_sep_nres_map: "\<lbrakk> disj_nres_map rs_map \<rbrakk> \<Longrightarrow> sep_nres_map (nres_lookup rs_map x) (rem_env rs_map x)"    
  apply (simp add: disj_nres_map_def)
  apply (simp add: sep_nres_map_def)
  apply (auto)
  apply (case_tac "x = xa")
   apply (simp add: nres_lookup_def)
   apply (simp add: rem_env_def)
   apply (rule_tac empty_strong_disj_use_env2)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="xa" in allE)
  apply (auto)
  apply (simp add: nres_lookup_def)
  apply (simp add: rem_env_def)
  done
  
  
lemma trans_sub_use_env: "\<lbrakk> sub_use_env s r_s; leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> sub_use_env s r_x"    
  apply (simp add: sub_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (case_tac "r_x x")
    apply (auto)
  done
    
    (*(\<lambda>i. if i = int (length arr) + n then Some r_s else rs_list i) *)
lemma well_typed_ext_array: "\<lbrakk> well_typed_list env delta r_s arr t; well_typed env delta r_s v t r_s r_s; is_value v \<rbrakk> \<Longrightarrow>
  well_typed_list env delta r_s (ext_list arr v) t"    
  apply (induction arr)
   apply (auto)(*
  apply (rule_tac t="1 + int (length arr) + n" and s="int (length arr) + (n + 1)" in subst)
   apply (auto)*)
  done
    
  
lemma spec_infl_leq_use_env: "\<lbrakk> leq_use_env r_ex r_s; mini_disj_use_env r_ex r_x; strong_use_env r_ex \<rbrakk> \<Longrightarrow> leq_use_env r_ex (infl_use_env r_s r_x)"    
  apply (simp add: leq_use_env_def)
  apply (simp add: infl_use_env_def)
  apply (simp add: strong_use_env_def)
  apply (auto)
   apply (case_tac "r_ex x")
     apply (auto)
   apply (erule_tac x="x" in allE)
   apply (case_tac "r_s x")
     apply (auto)
  apply (case_tac "r_ex x")
    apply (auto)
  apply (simp add: mini_disj_use_env_def)
  done
  

lemma ext_path_lookup: "path_lookup rs_map x l z \<Longrightarrow> (\<exists> l. path_lookup (add_env rs_map z r_s) x l z)"    
  apply (induct l arbitrary: x)
   apply (auto)
   apply (rule_tac x="Nil" in exI)
   apply (auto)
  apply (case_tac "x = z")
   apply (rule_tac x="Nil" in exI)
   apply (auto)
  apply (case_tac "rs_map x")
   apply (auto)
  apply (case_tac "\<exists> l. path_lookup (add_env rs_map z r_s) a l z")
   apply (erule_tac exE)
   apply (rule_tac x="a # la" in exI)
   apply (auto)
  apply (simp add: add_env_def)
  done
    (*
lemma ext_proper_exp: "\<lbrakk> proper_exp rs_map (VarExp (LocType x y)) \<rbrakk> \<Longrightarrow> proper_exp (add_env rs_map x r_s) (VarExp (LocType x y))"    
  apply (simp add: proper_exp_def)
  apply (auto)
  apply (rule_tac l="l" in ext_path_lookup)
  apply (auto)
  done

    
lemma ext_proper_list: "\<lbrakk> proper_list rs_map arr; proper_exp rs_map v \<rbrakk> \<Longrightarrow> proper_list rs_map (ext_list arr v)"    
  apply (induct arr)
   apply (auto)
  done*)
  
lemma add_path_lookup_some: "\<lbrakk> path_lookup rs_map x l y; rs_map z = Some r_x; leq_use_env r_x r_s \<rbrakk> \<Longrightarrow> path_lookup (add_env rs_map z r_s) x l y"    
  apply (induct l arbitrary: x)
   apply (auto)
  apply (case_tac "rs_map x")
   apply (auto)
  apply (case_tac "x \<noteq> z")
   apply (auto)
   apply (simp add: add_env_def)
  apply (simp add: add_env_def)
  apply (auto)
  apply (cut_tac r_x="r_x" and r_s="r_s" and x="Loc a" in leq_use_none)
    apply (auto)
  done
    
lemma add_path_lookup_gen: "\<lbrakk> path_lookup rs_map x l y; leq_use_env (nres_lookup rs_map z) r_s; x \<noteq> z \<rbrakk> \<Longrightarrow> path_lookup (add_env rs_map z r_s) x l y"
  apply (case_tac "rs_map z = None")
   apply (rule_tac add_path_lookup)
     apply (auto)
  apply (rule_tac r_x="nres_lookup rs_map z" in add_path_lookup_some)
    apply (auto)
  apply (simp add: nres_lookup_def)
  done
    
lemma ext_proper_delta: "\<lbrakk> proper_delta s delta; s x \<noteq> None \<rbrakk> \<Longrightarrow>
  proper_delta (add_env s x v) (ext_delta delta x r_s)"  
  apply (simp add: proper_delta_def)
  apply (auto)
    (* for every s' xa, s' (delta' xa). say that xa \<noteq> x *)
  apply (case_tac "xa \<noteq> x")
   apply (erule_tac x="xa" in allE)
   apply (simp add: add_env_def)
   apply (case_tac "s xa")
    apply (auto)
   apply (simp add: ext_delta_def)
   apply (auto)
    apply (simp add: add_env_def)
   apply (simp add: add_env_def)
    (* otherwise, xa = x *)
  apply (simp add: add_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (simp add: ext_delta_def)
  done

lemma ext_proper_delta2: "\<lbrakk> proper_delta s delta; s x \<noteq> None \<rbrakk> \<Longrightarrow>
  proper_delta (add_env s x v) (ext_delta delta (delta x) r_s)"  
  apply (simp add: proper_delta_def)
  apply (auto)
    (* we want to show that for every s' xa, s' (delta' xa). say that xa \<noteq> x unchanged from s *)
  apply (case_tac "xa \<noteq> x")
   apply (simp add: add_env_def)
   apply (case_tac "s xa")
    apply (auto)
   apply (simp add: ext_delta_def)
   apply (auto)
    (* - say that delta' xa \<noteq> delta xa. then delta' xa = delta x. since s (delta x), s' (delta x) *)
    apply (erule_tac x="x" in allE)
    apply (simp add: add_env_def)
    (* - otherwise, since s (delta xa), s' (delta xa) *)
   apply (erule_tac x="xa" in allE)
   apply (simp add: add_env_def)
    (* otherwise, xa = x *)
  apply (simp add: add_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (simp add: ext_delta_def)
  done    
    
    (*
lemma ext_proper_delta: "\<lbrakk> proper_delta s delta rs_map; sep_nres_map r_s rs_map; s x \<noteq> None \<rbrakk> \<Longrightarrow>
  proper_delta (add_env s x v) (ext_delta delta x r_s) (add_env rs_map x (comp_use_env (nres_lookup rs_map x) r_s))"  
  apply (simp add: proper_delta_def)
  apply (auto)
    (* we assume that a path delta xa \<longrightarrow> xa exists in rs_map, since otherwise s xa = None. *)
  apply (case_tac "\<not> (\<exists> l. path_lookup rs_map (delta xa) l xa)")
   apply (case_tac "s xa = None")
    apply (case_tac "x = xa")
     apply (auto)
    apply (simp add: add_env_def)
   apply (erule_tac x="xa" in allE)
   apply (auto)
  apply (case_tac "add_env s x v xa")
   apply (auto)
    (* we want to prove that if the path delta xa \<longrightarrow> xa exists in rs_map, then delta' xa \<longrightarrow> xa exists in the new rs_map.
        - say that delta' xa \<noteq> delta xa. then delta xa must be in r_s and delta' xa = x. *)
  apply (case_tac "ext_delta delta x r_s xa \<noteq> delta xa")
   apply (simp add: ext_delta_def)
   apply (case_tac "r_s (Loc (delta xa)) = NoPerm")
    apply (auto)
    (* - given that we construct a path from x \<longrightarrow> delta xa \<longrightarrow> xa in the new rs_map *)
   apply (rule_tac x="(delta xa) # l" in exI)
   apply (auto)
   apply (case_tac "add_env rs_map x (comp_use_env (nres_lookup rs_map x) r_s) x \<noteq> Some (comp_use_env (nres_lookup rs_map x) r_s)")
    apply (simp add: add_env_def)
   apply (auto)
    apply (cut_tac r_sb="r_s" and x="Loc (delta xa)" in comp_use_none_both)
     apply (auto)
   apply (rule_tac add_path_lookup_gen)
     apply (auto)
   apply (rule_tac self_comp_leq_use_env1)
    (* - otherwise, delta' xa = delta xa. now if delta xa \<noteq> x OR rs_map x \<noteq> None, we can show delta xa \<longrightarrow> x in the new rs_map easily. *)
  apply (case_tac "delta xa \<noteq> x")
   apply (rule_tac x="l" in exI)
   apply (rule_tac add_path_lookup_gen)
     apply (auto)
   apply (rule_tac self_comp_leq_use_env1)
  apply (case_tac "rs_map x \<noteq> None")
   apply (rule_tac x="l" in exI)
   apply (rule_tac r_x="nres_lookup rs_map x" in add_path_lookup_some)
     apply (auto)
    apply (simp add: nres_lookup_def)
   apply (rule_tac self_comp_leq_use_env1)
    (* - otherwise, we have l = [], meaning delta xa = xa = x, the empty path *)
   apply (case_tac l)
   apply (auto)
  apply (rule_tac x="[]" in exI)
  apply (auto)
  done*)
    

 
  
    (*
lemma well_typed_ext_delta: "\<lbrakk> well_typed env delta r_s1 e tau r_s2 rx; strong_disj_use_env r_s1 r_x; ref_memory env \<rbrakk> \<Longrightarrow>
  well_typed env (ext_delta delta x r_x) r_s1 e tau r_s2 rx"
  apply (cut_tac delta="delta" and x="x" and r_s="r_x" in loc_restr_ext_delta)
  apply (auto)
  apply (rule_tac well_typed_ext_delta_ih)
     apply (auto)
   apply (rule_tac r_s="r_x" in strong_disj_leq_use_env2)
    apply (simp)
   apply (rule_tac loc_restr_leq_use_env)
  apply (rule_tac loc_restr_use_env)
  done

lemma well_typed_list_ext_delta: "\<lbrakk> well_typed_list env delta r_s l i tau; strong_disj_use_env r_s r_x; ref_memory env; \<forall> i r_x. rs_list i = Some r_x \<longrightarrow> leq_use_env r_x r_s \<rbrakk> \<Longrightarrow>
  well_typed_list env (ext_delta delta x r_x) rs_list l i tau"
  apply (induct l arbitrary: i)
   apply (auto)
  apply (rule_tac well_typed_ext_delta)
  apply (auto)
  apply (rule_tac r_s="r_s" in strong_disj_leq_use_env1)
   apply (simp_all)
  done
    
lemma well_typed_mv_ext_delta: "\<lbrakk> well_typed_mem_value env delta r_s tau v; strong_disj_use_env r_s r_x; ref_memory env \<rbrakk> \<Longrightarrow>
  well_typed_mem_value env (ext_delta delta x r_x) r_s tau v"    
  apply (case_tac v)
    apply (auto)
  apply (rule_tac x="rs_list" in exI)
  apply (auto)
  apply (rule_tac well_typed_list_ext_delta)
     apply (auto)
  apply (simp add: valid_res_list_def)
  done*)

    
    
definition single_use_env where
  "single_use_env r_s x r = (\<forall> z. case z of
    Var x \<Rightarrow> True
    | Loc y \<Rightarrow> r_s z = (if y = x then r else NoPerm)
  )"    
    
lemma pair_rv_delta: "\<lbrakk> rv_delta delta e1 x; rv_delta delta e2 x \<rbrakk> \<Longrightarrow> rv_delta delta (PairExp e1 e2) x"    
  apply (simp add: rv_delta_def)
  done
    
lemma if_rv_delta: "\<lbrakk> rv_delta delta e1 x; rv_delta delta e2 x; rv_delta delta e3 x \<rbrakk> \<Longrightarrow> rv_delta delta (IfExp e1 e2 e3) x"    
  apply (simp add: rv_delta_def)
  done
 
lemma lam_rv_delta: "\<lbrakk> rv_delta delta e x \<rbrakk> \<Longrightarrow> rv_delta delta (LamExp x' e) x"    
  apply (simp add: rv_delta_def)
  done

lemma app_rv_delta: "\<lbrakk> rv_delta delta e1 x; rv_delta delta e2 x \<rbrakk> \<Longrightarrow> rv_delta delta (AppExp e1 e2) x"    
  apply (simp add: rv_delta_def)
  done
    
    (* prove that if an expression is typable with { delta(x): * }, then for all z in e, delta x \<longrightarrow> z.
        for this to be true, we assume the environment is a memory
    *)
lemma well_typed_rv_delta: "\<lbrakk> well_typed env delta r_s e tau r_s' r_x; single_use_env r_s (delta x) UsePerm; mem_val_env env \<rbrakk> \<Longrightarrow> rv_delta delta e (delta x)"    
  apply (induct e arbitrary: env tau r_s r_s' r_x)
        apply (auto)
    (* const + op cases *)
        apply (simp add: rv_delta_def)
       apply (simp add: rv_delta_def)
    (* var case *)
      apply (simp add: rv_delta_def)
      apply (auto)
      apply (case_tac xa)
       apply (auto)
      apply (case_tac "delta x2 \<noteq> delta x")
       apply (auto)
      apply (cut_tac r_x="ereq_use_env (Loc (delta x2)) tau_x" and r_s="r_s" and x="Loc (delta x2)" in leq_use_none)
        apply (simp)
       apply (simp add: single_use_env_def)
       apply (erule_tac x="Loc (delta x2)" in allE)
       apply (auto)
      apply (simp add: ereq_use_env_def)
      apply (simp add: one_use_env_def)
      apply (simp add: end_req_perm_def)
      apply (simp add: mem_val_env_def)
      apply (erule_tac x="Loc (delta x2)" in allE)
      apply (auto)
      apply (case_tac tau_x)
            apply (auto)
    (* pair case *)
     apply (rule_tac pair_rv_delta)
      apply (auto)
     apply (cut_tac env="env" and r_c="r_s" and ?r_s1.0="r_s2" and e="e2" in well_typed_incr_start_perm)
       apply (simp)
      apply (rule_tac well_typed_perm_leq)
      apply (auto)  
    (* if case *)
    apply (cut_tac env="env" and r_c="r_s" and ?r_s1.0="r_s2" and e="e2" in well_typed_incr_start_perm)
      apply (simp)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (cut_tac env="env" and r_c="r_s" and ?r_s1.0="r_s2" and e="e3" in well_typed_incr_start_perm)
      apply (simp)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac if_rv_delta)
      apply (auto)
    (* lam case *)
   apply (cut_tac env="env" and x="x1a" and tau="t1" in add_mem_val_env)
    apply (auto)
   apply (cut_tac env="add_env env (Var x1a) t1" and r_c="add_use_env r_s (Var x1a) r" and ?r_s1.0="add_use_env rx (Var x1a) r" and e="e" in well_typed_incr_start_perm)
     apply (simp)
    apply (rule_tac dist_add_leq_use_env)
    apply (simp)
   apply (case_tac "\<not> single_use_env (add_use_env r_s (Var x1a) r) (delta x) UsePerm")
    apply (simp add: single_use_env_def)
    apply (auto)
    apply (erule_tac x="z" in allE)
    apply (case_tac z)
     apply (auto)
    apply (simp add: add_use_env_def)
   apply (rule_tac lam_rv_delta)
   apply (auto)
    (* app case *)
  apply (rule_tac app_rv_delta)
   apply (auto)
  apply (cut_tac env="env" and r_c="r_s" and ?r_s1.0="r_s2" and e="e2" in well_typed_incr_start_perm)
    apply (simp)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
  done

lemma well_typed_rv_delta_gen_ih: "\<lbrakk> well_typed env delta r_s e tau r_s' r_x; leq_use_env (loc_restr r_s) r_c; mem_val_env env \<rbrakk> \<Longrightarrow> rv_delta (ext_delta delta x r_c) e x"    
  apply (induct e arbitrary: env r_s tau r_s' r_x)  
        apply (auto)
    (* const + op cases *)
        apply (simp add: rv_delta_def)
       apply (simp add: rv_delta_def)
    (* var case *)
      apply (simp add: rv_delta_def)
      apply (auto)
      apply (case_tac "xa")
       apply (auto)
      apply (case_tac "r_c (Loc (delta x2)) = NoPerm")
       apply (cut_tac r_x="loc_restr (ereq_use_env (Loc (delta x2)) tau_x)" and r_s="r_c" and x="Loc (delta x2)" in leq_use_none)
         apply (rule_tac r_sb="loc_restr r_s" in trans_leq_use_env)
          apply (auto)
        apply (rule_tac dist_loc_restr_leq_use_env)
        apply (simp)
       apply (simp add: loc_restr_def)
       apply (simp add: ereq_use_env_def)
       apply (simp add: one_use_env_def)
       apply (simp add: end_req_perm_def)
       apply (simp add: mem_val_env_def)
       apply (erule_tac x="Loc (delta x2)" in allE)
       apply (auto)
       apply (case_tac "tau_x")
             apply (auto)
      apply (simp add: ext_delta_def)
    (* pair case *)
     apply (rule_tac pair_rv_delta)
      apply (auto)
     apply (cut_tac r_sc="loc_restr r_s2" and r_sb="loc_restr r_s" and r_sa="r_c" in trans_leq_use_env)
       apply (auto)
     apply (rule_tac dist_loc_restr_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    (* if case *)
    apply (cut_tac r_sc="loc_restr r_s2" and r_sb="loc_restr r_s" and r_sa="r_c" in trans_leq_use_env)
      apply (auto)
     apply (rule_tac dist_loc_restr_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac if_rv_delta)
      apply (auto)
    (* lam case *)
   apply (rule_tac lam_rv_delta)
   apply (cut_tac r_sc="loc_restr (add_use_env rx (Var x1a) r)" and r_sb="loc_restr r_s" and r_sa="r_c" in trans_leq_use_env)
     apply (simp)
    apply (case_tac "loc_restr (add_use_env rx (Var x1a) r) \<noteq> loc_restr rx")
     apply (case_tac "\<forall> x. loc_restr (add_use_env rx (Var x1a) r) x = loc_restr rx x")
      apply (auto)
     apply (simp add: loc_restr_def)
     apply (case_tac xa)
      apply (auto)
     apply (simp add: add_use_env_def)
    apply (rule_tac dist_loc_restr_leq_use_env)
    apply (simp)
   apply (cut_tac env="env" and x="x1a" and tau="t1" in add_mem_val_env)
    apply (auto)
    (* app case *)
  apply (rule_tac app_rv_delta)
   apply (auto)
  apply (cut_tac r_sc="loc_restr r_s2" and r_sb="loc_restr r_s" and r_sa="r_c" in trans_leq_use_env)
    apply (auto)
  apply (rule_tac dist_loc_restr_leq_use_env)
  apply (rule_tac well_typed_perm_leq)
  apply (auto)
  done
    
lemma well_typed_rv_delta_gen: "\<lbrakk> well_typed env delta r_s e tau r_s' r_x; mem_val_env env \<rbrakk> \<Longrightarrow> rv_delta (ext_delta delta x r_s) e x"      
  apply (cut_tac delta="delta" and x="x" and r_s="r_s" in loc_restr_ext_delta)
  apply (auto)
  apply (rule_tac well_typed_rv_delta_gen_ih)
    apply (auto)
  apply (rule_tac id_leq_use_env)
  done

    (* proving that a value originally typable with { delta(x): *} will be typable with { delta'(x): * }
      where delta' = delta + { a \<longrightarrow> r_s } *)    
lemma well_typed_value_ext_delta: "\<lbrakk> well_typed env delta (one_use_env (Loc (delta x)) UsePerm) v tau
      (one_use_env (Loc (delta x)) UsePerm) (one_use_env (Loc (delta x)) UsePerm); is_value v;
    well_formed_delta env delta; env (Loc x) = Some (ArrayTy tau); env (Loc a) = Some tx; mem_val_env env; sub_env s env \<rbrakk> \<Longrightarrow>
            well_typed env (ext_delta delta a r_s) (one_use_env (Loc (ext_delta delta a r_s x)) UsePerm) v tau (one_use_env (Loc (ext_delta delta a r_s x)) UsePerm)
             (one_use_env (Loc (ext_delta delta a r_s x)) UsePerm)"     
    (* delta' x is in the env since either it's the same, or it is a. *)
  apply (case_tac "env (Loc (ext_delta delta a r_s x)) = None")
   apply (auto)
   apply (simp add: ext_delta_def)
   apply (auto)
   apply (simp add: well_formed_delta_def)
   apply (erule_tac x="x" in allE)
   apply (auto)
  apply (rule_tac wt_read_value)
           apply (auto)
     apply (simp add: mem_val_env_def)
     apply (erule_tac x="Loc (ext_delta delta a r_s x)" in allE)
     apply (auto)
    apply (simp add: mem_val_env_def)
    apply (erule_tac x="Loc x" in allE)
    apply (auto)
   apply (simp add: one_use_env_def)
    (* rv_delta is a requirement that delta' x \<longrightarrow> z for all z in e. (that the owner of x is the same as the owner of all variables in e).
        - in the previous exrpession we should have delta x \<longrightarrow> z for all z in e. *)
  apply (cut_tac delta="delta" and x="x" and r_s="one_use_env (Loc (delta x)) UsePerm" and e="v" in well_typed_rv_delta)
     apply (auto)
   apply (simp add: single_use_env_def)
   apply (auto)
   apply (case_tac z)
    apply (auto)
    apply (simp add: one_use_env_def)
   apply (simp add: one_use_env_def)  
    (* - since delta x \<longrightarrow> z, we have r_s (delta z) = r_s (delta x), meaning z's owner can change only if x's owner changes *)
  apply (simp add: rv_delta_def)
  apply (auto)
  apply (simp add: ext_delta_def)
  done
    
lemma well_typed_list_ext_delta: "\<lbrakk> well_typed_list env delta (one_use_env (Loc (delta x)) UsePerm) l tau; well_formed_delta env delta;
    env (Loc x) = Some (ArrayTy tau); env (Loc a) = Some tx; mem_val_env env; sub_env s env \<rbrakk> \<Longrightarrow>
            well_typed_list env (ext_delta delta a r_s) (one_use_env (Loc (ext_delta delta a r_s x)) UsePerm) l tau"    
  apply (induct l)
   apply (auto)
  apply (rule_tac well_typed_value_ext_delta)
        apply (auto)
  done
    
lemma well_typed_mv_ext_delta: "\<lbrakk> well_typed_mem_value env delta (one_use_env (Loc (delta x)) UsePerm) tau v; well_formed_delta env delta;
  env (Loc x) = Some tau; env (Loc a) = Some tx; mem_val_env env; sub_env s env \<rbrakk> \<Longrightarrow>
  well_typed_mem_value env (ext_delta delta a r_s) (one_use_env (Loc (ext_delta delta a r_s x)) UsePerm) tau v"    
  apply (case_tac v)
    apply (auto)
  apply (rule_tac well_typed_list_ext_delta)
        apply (auto)
  done
  

    (*
lemma scv_ext_array_alt: "
  \<lbrakk>well_typed_state s1 env delta; sub_use_env s1 r_f; leq_use_env r_s1 r_f; are = CVApp;
        req_type tau = Ref; req_type tau_x = Ref;
        well_typed env delta r_s1 (ext_app_abbrev (LocType ab) v) tau r_s2 rx; is_value v;
        s1 ab = Some (ArrValue arr); env (Loc ab) = Some tau; env (Loc (delta ab)) = Some tau_x \<rbrakk>
       \<Longrightarrow>  \<exists>g_ax. red_env env g_ax (Loc ab) = Some tau \<and>
           (\<exists>r_ex tau_x.
               red_env env g_ax (Loc (red_delta delta g_ax ab)) = Some tau_x \<and>
               leq_use_env (ereq_use_env (Loc (red_delta delta g_ax ab)) tau_x) (exp_red_use_env r_s1 g_ax) \<and>
               leq_use_env (end_red_use_env r_s2 g_ax)
                (diff_use_env (exp_red_use_env r_s1 g_ax) (comp_use_env (ereq_use_env (Loc (red_delta delta g_ax ab)) tau_x) r_ex)) \<and>
               leq_use_env (end_red_use_env rx g_ax) (end_red_use_env r_s2 g_ax) \<and>
               leq_use_env r_ex (exp_red_use_env r_s1 g_ax) \<and>
               leq_use_env
                (diff_use_env (ereq_use_env (Loc (red_delta delta g_ax ab)) tau_x) (comp_use_env (ereq_use_env (Loc (red_delta delta g_ax ab)) tau_x) r_ex))
                (end_red_use_env rx g_ax)) \<and>
           well_typed_state (add_env s1 ab (ArrValue (ext_list arr v))) (red_env env g_ax) (red_delta delta g_ax) \<and>
           sub_use_env (add_env s1 ab (ArrValue (ext_list arr v))) (exp_red_use_env r_f g_ax) \<and>
           safe_act s1 (infl_use_env r_f r_s2) g_ax \<and> corr_act (UseAct ab) g_ax"   
  apply (simp add: ext_app_abbrev_def)
  apply (auto)
    (* - prelim: req_type tau \<noteq> Prim *)(*
  apply (case_tac "req_type tau = Prim")
   apply (cut_tac v="ab" and tau="tau" in var_value_prim1)
     apply (simp)
    apply (simp add: ext_arr_abbrev_def)
    apply (simp add: pure_fun_def)
   apply (auto)*)
  apply (simp add: app_req_def)
    (* structuring *)
  apply (cut_tac env="env" and ?r_s1.0="r_s1" and ?r_s2.0="r_s2" and v="LocType ab" and rx="rx" and
      ?t1.0="t1" and ?t2.0="tau" and r="r" and a="a" in ext_var_type2)
   apply (rule_tac ?r_s2.0="diff_use_env r_s2a (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" and
      rx="diff_use_env rx1 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in well_typed_simul_end_perm)
      apply (rule_tac well_typed_diff_end_perm)
       apply (simp)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
   apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac dist_diff_leq_use_env)
   apply (rule_tac self_comp_leq_use_env1)
    (* - prelim: r = Own *)
  apply (case_tac "\<not> is_own r")
   apply (simp add: ext_arr_abbrev_def)
   apply (simp add: pure_fun_def)
   apply (simp add: is_own_def)
    (* - prelim: proving the greater rx1 + rx2 are disjoint *)
  apply (cut_tac ?r_s1.0="rx1" and ?r_s2.0="infl_use_env r_s1 r_s2a" and r_ex="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r"in disj_comp_use_env1)
    apply (simp add: lift_comp_use_env)
    apply (rule_tac disj_comp_use_env2)
     apply (simp)
    apply (simp add: infl_lift_use_env)
    apply (rule_tac infl_disj_use_env)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env1)
   apply (simp add: lift_comp_use_env)
   apply (rule_tac disj_comp_use_env2)
    apply (rule_tac comm_disj_use_env)
    apply (rule_tac infl_disj_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env2)
   apply (simp add: infl_lift_use_env)
   apply (rule_tac comm_disj_use_env)
   apply (rule_tac infl_disj_use_env)
   apply (rule_tac lhs_infl_leq_use_env)
   apply (rule_tac id_leq_use_env)
    (* showing that rx2 is removable from the var *)
  apply (cut_tac env="env" and ?r_s1.0="r_s1" and e="var_abbrev (LocType ab)" and ?r_s2.0="r_s2" and rx="rx" and
      ?rx1.0="comp_use_env rx1 (infl_use_env r_s1 r_s2a)" and ?rx2.0="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" in spec_disj_diff_perms)
       apply (auto)
     apply (rule_tac wts_well_formed_delta)
     apply (auto)
    apply (simp add: var_abbrev_def)
   apply (rule_tac ext_var_type)
   apply (rule_tac ext_arr_type)
     apply (auto)
   apply (rule_tac wts_well_formed_delta)
   apply (auto)
    (* - prelim: rx2 + [r_s2a - r_s3] \<le> r_f (useful inequality) *)
  apply (cut_tac r_sc="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" and r_sb="r_s1" and r_sa="r_f" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (simp add: lift_comp_use_env)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env2)
   apply (simp add: infl_lift_use_env)
   apply (rule_tac lhs_infl_leq_use_env)
   apply (rule_tac id_leq_use_env)
    (* - prelim: ref_memory env / well_formed_delta *)
  apply (cut_tac env="env" in wts_mem_val_env)
   apply (auto)
  apply (cut_tac delta="delta" in wts_well_formed_delta)
   apply (auto)
    (* concretizing t1 *)
  apply (case_tac "ArrayTy t1 \<noteq> tau")
   apply (simp add: ext_arr_abbrev_def)
   apply (simp add: pure_fun_def)
  apply (auto)
    (* existentials *)
  apply (rule_tac x="WriteResAct ab (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r)" in exI)
  apply (auto)
    (* to prove well-typedness, we must demonstrate that final array has the same owner (itself).
        this is true since its permission will be on the lhs, and all changed permissions are in the rhs.
    *)
     apply (case_tac "lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r (Loc (delta ab)) \<noteq> NoPerm")
      apply (case_tac "lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r (Loc (delta ab)) = OwnPerm")
       apply (case_tac "comp_use_env rx1 (infl_use_env r_s1 r_s2a) (Loc (delta ab)) \<noteq> NoPerm")
        apply (simp add: disj_use_env_def)
       apply (simp add: mini_disj_use_env_def)
    (* - first we have to prove that ab's ancestor is in rx1 + [r_s1 - r_s2a]. *)
      apply (cut_tac env="env" and ?r_s1.0="r_s1" and ?r_s2.0="r_s2a" and v="LocType ab" and rx="rx1" and
        ?t1.0="t1" and ?t2.0="ArrayTy t1" and r="r" and a="a" in ext_var_type2)
       apply (auto)
      apply (cut_tac env="env" and rx="rx1" and ?r_s1.0="r_s1" and ?r_s2.0="r_s2a" and v="ab" and tau_x="tau_x" in ext_var_loc_none)
          apply (auto)
    (* then we show that rx2 + [r_s2a - r_s3] is ownership. *)
      apply (simp add: is_own_def)
      apply (case_tac "comp_use_env rx2 (infl_use_env r_s2a r_s3) (Loc (delta ab))")
        apply (auto)
    (* - actual well-typedness comes easily *)
     apply (simp add: var_abbrev_def)
     apply (case_tac "ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab \<noteq> delta ab")
      apply (simp add: ext_delta_def)
     apply (auto)
    (* proving the state remains well-typed *)
    apply (simp add: well_typed_state_def)
    apply (auto)
    (* environment contained in the state *)
       apply (rule_tac add_sub_env)
       apply (simp)
    (* validity: res_map completeness *)(*
      apply (simp add: valid_nres_map_def)
      apply (auto)
        apply (rule_tac add_full_nres_map)
        apply (simp)
    (* - res_map self disjointness *)
       apply (rule_tac disj_add_nres_map)
        apply (simp)
       apply (rule_tac comp_sep_nres_map)
        apply (rule_tac simp_sep_nres_map)
        apply (simp)
       apply (rule_tac r_s="r_f" in leq_sep_nres_map)
        apply (simp)
       apply (simp add: valid_exp_use_env_def)
       apply (auto)
       apply (rule_tac rs_map="rs_map" in sub_sep_nres_map)
        apply (rule_tac rem_contain_env)
        apply (rule_tac id_contain_env)
       apply (simp)
    (* - res_map element containment *)
      apply (rule_tac dist_add_sub_nres_map)
       apply (simp)
      apply (rule_tac comp_sub_use_env)
       apply (simp add: sub_nres_map_def)
      apply (rule_tac r_s="r_f" in trans_sub_use_env)
       apply (simp add: valid_exp_use_env_def)
      apply (simp)*)
    (* proving that delta remains proper *)
     apply (rule_tac ext_proper_delta2)
       apply (auto)(*
     apply (rule_tac r_s="r_f" in leq_sep_nres_map)
      apply (simp)
     apply (simp add: valid_exp_use_env_def)*)
    (* proving that the array is still well-typed r
      - prelim: disjointness of rs_map x + lift(rx2 + [r_s2a - rs3]) *)(*
    apply (cut_tac r_ex="nres_lookup rs_map x" and r_x="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" and r_s="r_f" in strong_disj_leq_use_env2)
      apply (simp add: nres_lookup_def)
      apply (case_tac "rs_map x")
       apply (auto)
      apply (rule_tac empty_strong_disj_use_env1)
     apply (rule_tac comm_strong_disj_use_env)
     apply (simp add: valid_exp_use_env_def)
     apply (simp add: sep_nres_map_def)
     apply (auto)
     apply (erule_tac x="x" in allE)
     apply (erule_tac x="x" in allE)
     apply (simp add: nres_lookup_def)*)
    (* xa \<noteq> deref_name x ab case *)
    apply (case_tac "x \<noteq> ab")
     apply (simp add: add_env_def)
     apply (erule_tac x="x" in allE)
     apply (case_tac "s1 x")
      apply (auto)
     apply (case_tac "env (Loc x)")
      apply (auto)
     apply (rule_tac well_typed_mv_ext_delta)
           apply (auto)
    (* xa = deref_name x ab case *)
    apply (case_tac "add_env s1 ab (ArrValue (ext_list arr v)) ab = None")
     apply (simp add: add_env_def)
    apply (auto)
    apply (simp add: add_env_def)
    apply (erule_tac x="ab" in allE)
    apply (auto)
    apply (rule_tac well_typed_ext_array)
      apply (rule_tac well_typed_list_ext_delta)
           apply (auto)
    apply (case_tac "env (Loc (ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab)) = None")
     apply (simp add: ext_delta_def)
     apply (auto)
    apply (rule_tac t="y" in wt_read_value)
             apply (rule_tac well_typed_lift_req)
              apply (rule_tac well_typed_lift_perms)
              apply (rule_tac infl_sexp_wp)
                apply (auto)
        apply (rule_tac value_is_sexp)
        apply (simp)
       apply (rule_tac id_leq_use_env)
      apply (simp add: mem_val_env_def)
      apply (erule_tac x="Loc (ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab)" in allE)
      apply (auto)
     apply (simp add: one_use_env_def)
    apply (cut_tac e="v" and r_s="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" and env="env" and delta="delta" and x="delta ab" in well_typed_rv_delta_gen)
      apply (rule_tac well_typed_lift_req)
       apply (rule_tac well_typed_lift_perms)
       apply (rule_tac infl_sexp_wp)
         apply (auto)
      apply (rule_tac value_is_sexp)
      apply (auto)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac t="ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab" and
       s="delta ab" in subst)
     apply (simp add: ext_delta_def)
    apply (simp)
    (*
   apply (rule_tac x="(\<lambda> i. if i = int (length arr) then Some (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) else rs_list i)" in exI)
  apply (auto)
    (* - proving the function used to type the array is valid *)
    apply (simp add: valid_res_list_def)
    apply (auto)
    (* - i = length arr *)
       apply (simp add: nres_lookup_def)
       apply (rule_tac self_comp_leq_use_env2)
      apply (simp add: disj_res_list_def)
      apply (auto)
      apply (erule_tac x="j" in allE)
      apply (auto)
      apply (rule_tac r_s="nres_lookup rs_map ab" in strong_disj_leq_use_env2)
       apply (rule_tac r_s="r_f" in strong_disj_leq_use_env1)
        apply (simp add: valid_exp_use_env_def)
        apply (simp add: sep_nres_map_def)
       apply (simp_all)
    (* - i \<noteq> length arr *)
     apply (simp add: nres_lookup_def)
     apply (rule_tac comp_leq_use_env1)
     apply (erule_tac x="i" in allE)
     apply (auto)
    apply (simp add: disj_res_list_def)
    apply (erule_tac x="i" in allE)
    apply (auto)
    apply (rule_tac r_s="nres_lookup rs_map ab" in strong_disj_leq_use_env1)
     apply (rule_tac r_s="r_f" in strong_disj_leq_use_env2)
      apply (rule_tac comm_strong_disj_use_env)
      apply (simp add: valid_exp_use_env_def)
      apply (simp add: sep_nres_map_def)
     apply (auto)
    (* actual array well-typedness + properness *)
    (* all the previous array values should be typable with the new delta easily. the question is how to type the value that was just added.
        the idea is that using the read_value lemma, the extended delta should be able to accomodate.

        the main problem is that the new permission env will require the owner, which breaks our ordering. so to make this work, we require delayed adding.
    *)
    apply (cut_tac env="env" and delta="ext_delta delta ab (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r)" and arr="arr" and v="v" and n="0" and t="t1" and
        rs_list="rs_list" and r_s="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" in well_typed_ext_array)
       apply (auto)
     apply (rule_tac r_s="nres_lookup rs_map ab" in well_typed_list_ext_delta)
        apply (auto)
     apply (simp add: valid_res_list_def)
    
    
    apply (rule_tac well_typed_ext_delta)
      apply (rule_tac well_typed_lift_req)
       apply (rule_tac well_typed_lift_perms)
       apply (rule_tac infl_sexp_wp)
         apply (auto)
      apply (rule_tac value_is_sexp)
      apply (simp)
     apply (rule_tac id_leq_use_env)
    (* - properness *)
    apply (rule_tac proper_add_mv)
     apply (erule_tac x="ab" in allE)
     apply (simp add: add_env_def)
     apply (auto)
     apply (rule_tac ext_proper_list)
      apply (auto)
     apply (simp add: proper_exp_def)
    apply (rule_tac self_comp_leq_use_env1)*)
    (* validity of expression permissions: containment *)
   apply (rule_tac r_s="r_f" in trans_sub_use_env)
    apply (rule_tac add_sub_use_env)
    apply (simp)
   apply (rule_tac self_diff_leq_use_env)
    (*
    (* validity of expression permissions: containment *)
  apply (simp add: valid_exp_use_env_def)
  apply (auto)
   apply (rule_tac r_s="r_f" in trans_sub_use_env)
    apply (rule_tac add_sub_use_env)
    apply (simp)
   apply (rule_tac self_diff_leq_use_env)
    (* - separation of permissions *)
  apply (rule_tac add_sep_nres_map)
   apply (rule_tac r_s="r_f" in leq_sep_nres_map)
    apply (rule_tac self_diff_leq_use_env)
   apply (simp)
  apply (rule_tac strong_disj_comp_use_env1)
   apply (rule_tac r_s="r_f" in strong_disj_leq_use_env1)
    apply (simp add: sep_nres_map_def)
   apply (rule_tac self_diff_leq_use_env)
  apply (rule_tac diff_strong_disj_use_env)
  apply (rule_tac strong_lift_use_env)
   apply (simp)*)
    (* - action safety *)
  apply (rule_tac spec_infl_leq_use_env)
    apply (simp)
   apply (simp add: lift_comp_use_env)
   apply (rule_tac mini_disj_comp_use_env)
    apply (rule_tac r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in mini_disj_leq_use_env2)
     apply (rule_tac r_s="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in mini_disj_leq_use_env1)
      apply (rule_tac mini_disj_diff_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_comp_leq_use_env2)
    apply (simp)
   apply (simp add: infl_lift_use_env)
   apply (rule_tac gen_mini_disj_use_env2)
   apply (rule_tac infl_disj_use_env)
   apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
    apply (rule_tac self_diff_leq_use_env)
   apply (simp)
  apply (rule_tac strong_lift_use_env)
   apply (simp add: is_own_def)
  apply (simp add: corr_act_def)
  done*)
    
    (* ##### array write case ##### *)
    
definition write_arr_abbrev where
  "write_arr_abbrev v = AppExp (ConstExp WriteConst) (VarExp v)"  
  
definition write_pair_abbrev where
  "write_pair_abbrev i v = PairExp (ConstExp (IConst i)) v"  
  
definition write_app_abbrev where
  "write_app_abbrev a i v = AppExp (write_arr_abbrev a) (write_pair_abbrev i v)"      
    
lemma write_var_type: "\<lbrakk> well_typed env delta r_s1 (write_pair_abbrev i v) (PairTy t1 t2 r) r_s2 rx; is_own r \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 v t2 r_s2 rx"
  apply (simp add: write_pair_abbrev_def)
  apply (auto)
  apply (case_tac "req_type (PairTy t1 t2 r) = Prim")
   apply (simp add: is_own_def)
  apply (simp add: pair_req_def)
  apply (rule_tac ?r_s2.0="diff_use_env r_s3 r_ex" and rx="diff_use_env rx2 r_ex" in
      well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
       apply (auto)
  apply (rule_tac r_sb="diff_use_env (comp_use_env (lift_use_env rx1 r) (lift_use_env rx2 r)) r_ex" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env2)
  apply (rule_tac self_lift_leq_use_env)
  done
    
    (* in principle this is true because for each part of the list, the element is either
      "still" well-typed, or it has been replaced with v which is well-typed.
    *)
    
lemma corr_write_array_zero: "\<lbrakk> Some (a # arr') = write_array arr 0 v \<rbrakk> \<Longrightarrow> (\<exists> b. arr = b # arr' \<and> a = v)"
  apply (case_tac arr)
   apply (auto)
  done

lemma corr_write_array_nz: "\<lbrakk> Some (a # arr') = write_array arr i v; i \<noteq> 0 \<rbrakk> \<Longrightarrow>
  (\<exists> arr_x. arr = a # arr_x \<and> Some arr' = write_array arr_x (i - 1) v)"
  apply (case_tac arr)
   apply (auto)
   apply (case_tac "write_array list (i - 1) v")
    apply (auto)
  apply (case_tac "write_array list (i - 1) v")
   apply (auto)
  done    
  
lemma zero_sum: "\<lbrakk> (n:: int) = (i :: int) + n \<rbrakk> \<Longrightarrow> i = 0"    
  apply (auto)
  done
    (*
lemma wtwa_add_rev: "\<lbrakk> well_typed_list env delta r_s arr (n + i) t; i > 0 \<rbrakk> \<Longrightarrow>
  well_typed_list env delta r_s arr ((n :: int) + i) t"    
  apply (induct arr arbitrary: i)
   apply (auto)
  apply (case_tac "n + i + 1 = n + (i + 1)")
   apply (auto)
  apply (rule_tac t="n + i + 1" and s="n + (i + 1)" in subst)
   apply (auto)
  done
    
lemma proper_write_array: "\<lbrakk> proper_list rs_map arr; proper_exp rs_map v; Some arr' = write_array arr i v \<rbrakk> \<Longrightarrow> proper_list rs_map arr'"    
  apply (induct arr' arbitrary: i arr)
   apply (auto)
   apply (case_tac arr)
    apply (auto)
   apply (case_tac "i = 0")
    apply (auto)
   apply (case_tac "write_array list (i - 1) v")
    apply (auto)
  apply (case_tac arr)
   apply (auto)
  apply (case_tac "i = 0")
   apply (auto)
  apply (case_tac "write_array list (i - 1) v")
   apply (auto)
  apply (case_tac "Some ab = write_array list (i - 1) v")
   apply (iprover)
  apply (auto)
  done  *)
    
lemma well_typed_write_array: "\<lbrakk> well_typed_list env delta r_s arr t; well_typed env delta r_s v t r_s r_s;
  Some arr' = write_array arr i v; is_value v \<rbrakk> \<Longrightarrow>
  well_typed_list env delta r_s arr' t"    
  apply (induct arr' arbitrary: i arr)
   apply (simp)
    (* n = i, (i = 0) *)
  apply (case_tac "i = 0")
   apply (cut_tac arr="arr" and arr'="arr'" and v="v" and a="a" in corr_write_array_zero)
    apply (auto)
    (* n \<noteq> i *)
    apply (cut_tac arr="arr" and arr'="arr'" and v="v" and a="a" in corr_write_array_nz)
      apply (auto)
   apply (cut_tac arr="arr" and arr'="arr'" and v="v" and a="a" in corr_write_array_nz)
     apply (auto)
  apply (cut_tac arr="arr" and arr'="arr'" and v="v" and a="a" in corr_write_array_nz)
    apply (auto)
  done

lemma scv_write_case: "\<lbrakk> well_typed_state s1 env delta; sub_use_env s1 r_f; leq_use_env r_s1 r_f; are = CVApp;
        well_typed env delta r_s1 (write_app_abbrev (LocType ab) i v) tau r_s2 rx; is_value v;
        FunTy t1a (FunTy (PairTy IntTy t2 rb) tau r a) ra aa = pure_fun (ArrayTy t) (FunTy (PairTy IntTy t OwnPerm) UnitTy OwnPerm Ref) Prim;
        ax = UseAct x; s1 ab = Some (ArrValue arr); Some arr' = write_array arr i v;
        env (Loc ab) = Some t1a \<rbrakk>
       \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (red_delta delta g_ax) (exp_red_use_env r_s1 g_ax) unit_exp tau (end_red_use_env r_s2 g_ax) (end_red_use_env rx g_ax) \<and>
                  well_typed_state (add_env s1 ab (ArrValue arr')) (red_env env g_ax) (red_delta delta g_ax) \<and>
                  sub_use_env (add_env s1 ab (ArrValue arr')) (exp_red_use_env r_f g_ax) \<and>
                  safe_act s1 (infl_use_env r_f r_s2) g_ax \<and> corr_act (UseAct b) g_ax"
  apply (simp add: write_app_abbrev_def)
  apply (auto)
  apply (case_tac "t1 \<noteq> PairTy IntTy t2 rb")
   apply (simp add: write_arr_abbrev_def)
   apply (simp add: pure_fun_def)
   apply (auto)
    (* get the well-typedness statement for the value *)
  apply (cut_tac env="env" and ?r_s1.0="r_s2a" and i="i" and v="v" and ?t1.0="IntTy" and ?t2.0="t2" and
      r="rb" and ?r_s2.0="r_s3" and rx="rx2" in write_var_type)
    apply (auto)
   apply (simp add: is_own_def)
   apply (simp add: pure_fun_def)
    (* prelim: r = Own *)
  apply (case_tac "\<not> is_own r")
   apply (simp add: is_own_def)
   apply (simp add: pure_fun_def)
    (* prelim: r = rc *)
  apply (case_tac "r \<noteq> rc")
   apply (simp add: write_arr_abbrev_def)
   apply (simp add: pure_fun_def)
    (* prelim: constructed rx2 \<le> r_f *)
  apply (cut_tac r_sc="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" and r_sb="r_s1" and r_sa="r_f" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (rule_tac well_typed_perm_leq)
    apply (auto)
   apply (simp add: lift_comp_use_env)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (rule_tac well_typed_perm_leq)
     apply (auto)
    apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env2)
   apply (simp add: infl_lift_use_env)
   apply (rule_tac lhs_infl_leq_use_env)
   apply (rule_tac id_leq_use_env)
    (* prelim: well-formed delta / mem_val_env *)
  apply (cut_tac env="env" and delta="delta" in wts_well_formed_delta)
   apply (auto)
  apply (case_tac "env (Loc (delta ab)) = None")
   apply (simp add: well_formed_delta_def)
   apply (erule_tac x="ab" in allE)
   apply (auto)
  apply (cut_tac env="env" in wts_mem_val_env)
   apply (auto)
    (* well-typedness statement *)
  apply (rule_tac x="WriteResAct ab (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r)" in exI)
  apply (auto)
      apply (simp add: unit_exp_def)
      apply (auto)
        apply (simp add: pure_fun_def)
       apply (rule_tac dist_diff_leq_use_env)
       apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
        apply (rule_tac diff_leq_use_env)
        apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
       apply (rule_tac well_typed_perm_leq)
       apply (auto)
      apply (rule_tac dist_diff_leq_use_env)
      apply (simp)
    (* properness *)(*
     apply (simp add: proper_exp_def)
     apply (simp add: unit_exp_def)*)
    (* proving the state remains well-typed *)
    apply (simp add: well_typed_state_def)
    apply (auto)
    (* containment of env in state *)
      apply (rule_tac add_sub_env)
      apply (simp)
    (* validity of res_map: completeness *)(*
     apply (simp add: valid_nres_map_def)
     apply (auto)
       apply (rule_tac add_full_nres_map)
       apply (simp)
    (* - disjointness *)
      apply (rule_tac disj_add_nres_map)
       apply (simp)
      apply (rule_tac comp_sep_nres_map)
       apply (rule_tac simp_sep_nres_map)
       apply (simp)
      apply (rule_tac r_s="r_f" in leq_sep_nres_map)
       apply (simp)
      apply (simp add: valid_exp_use_env_def)
      apply (rule_tac rs_map="rs_map" in sub_sep_nres_map)
       apply (rule_tac rem_contain_env)
       apply (rule_tac id_contain_env)
      apply (simp)
    (* - element containment *)
     apply (rule_tac dist_add_sub_nres_map)
      apply (simp)
     apply (rule_tac comp_sub_use_env)
      apply (simp add: sub_nres_map_def)
     apply (rule_tac r_s="r_f" in trans_sub_use_env)
      apply (simp add: valid_exp_use_env_def)
     apply (simp)*)
    (* proper delta *)
     apply (rule_tac ext_proper_delta2)
      apply (auto)
    (* proving that the array is still well-typed : xa \<noteq> ab *)
    apply (case_tac "xa \<noteq> ab")
     apply (erule_tac x="xa" in allE)
     apply (simp add: add_env_def)
     apply (auto)
     apply (case_tac "s1 xa")
      apply (auto)
     apply (case_tac "env (Loc xa)")
      apply (auto)
     apply (rule_tac well_typed_mv_ext_delta)
          apply (auto)
    (* xa = ab case *)
    apply (case_tac "add_env s1 ab (ArrValue arr') ab = None")
     apply (simp add: add_env_def)
    apply (auto)
    apply (simp add: add_env_def)
    apply (erule_tac x="ab" in allE)
    apply (auto)
    apply (rule_tac well_typed_write_array)
       apply (auto)
     apply (rule_tac well_typed_list_ext_delta)
          apply (auto)
    apply (case_tac "env (Loc (ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab)) = None")
     apply (simp add: ext_delta_def)
    apply (auto)
    apply (rule_tac t="ya" and r_x="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" in wt_read_value)
             apply (rule_tac well_typed_lift_req)
              apply (rule_tac well_typed_lift_perms)
              apply (rule_tac infl_sexp_wp)
                  apply (auto)
         apply (simp add: pure_fun_def)
        apply (rule_tac value_is_sexp)
        apply (auto)
       apply (rule_tac id_leq_use_env)
      apply (simp add: mem_val_env_def)
      apply (erule_tac x="Loc (ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab)" in allE)
      apply (auto)
     apply (simp add: one_use_env_def)
    apply (cut_tac e="v" and r_s="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" and env="env" and delta="delta" and x="delta ab" in well_typed_rv_delta_gen)
      apply (rule_tac well_typed_lift_req)
       apply (rule_tac well_typed_lift_perms)
       apply (rule_tac infl_sexp_wp)
         apply (auto)
      apply (rule_tac value_is_sexp)
      apply (auto)
     apply (rule_tac id_leq_use_env)
    apply (rule_tac t="ext_delta delta (delta ab) (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) ab" and
       s="delta ab" in subst)
     apply (simp add: ext_delta_def)
    apply (simp)
    (*
    (* proving that the array is still well-typed + proper : xa \<noteq> deref_name x ab *)
    apply (case_tac "xa \<noteq> ab")
     apply (erule_tac x="xa" in allE)
     apply (simp add: add_env_def)
     apply (auto)
     apply (case_tac "s1 xa")
      apply (auto)
     apply (case_tac "env (Loc xa)")
      apply (auto)
      apply (simp add: nres_lookup_def)
      apply (simp add: add_env_def)
    (* - properness *)
     apply (rule_tac proper_add_mv)
      apply (simp)
     apply (rule_tac self_comp_leq_use_env1)*)
    (* xa = deref_name x ab case *)(*
    apply (case_tac "add_env s1 ab (ArrValue arr') ab = None")
     apply (simp add: add_env_def)
    apply (auto)
     apply (simp add: add_env_def)
     apply (erule_tac x="ab" in allE)
     apply (auto)
     apply (rule_tac x="(\<lambda> j. if j = i then Some (lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r) else rs_list j)" in exI)
     apply (auto)
    (* validity of res map function: ia = i *)
      apply (simp add: valid_res_list_def)
      apply (auto)
         apply (simp add: nres_lookup_def)
         apply (rule_tac self_comp_leq_use_env2)
        apply (simp add: disj_res_list_def)
        apply (auto)
        apply (erule_tac x="j" in allE)
        apply (auto)
        apply (rule_tac r_s="r_f" in strong_disj_leq_use_env1)
         apply (rule_tac r_s="nres_lookup rs_map ab" in strong_disj_leq_use_env2)
          apply (simp add: valid_exp_use_env_def)
          apply (simp add: sep_nres_map_def)
         apply (auto)
    (* ia \<noteq> i *)
       apply (simp add: nres_lookup_def)
       apply (erule_tac x="ia" in allE)
       apply (auto)
       apply (rule_tac comp_leq_use_env1)
       apply (simp)
      apply (simp add: disj_res_list_def)
      apply (erule_tac x="ia" in allE)
      apply (auto)
      apply (rule_tac r_s="nres_lookup rs_map ab" in strong_disj_leq_use_env1)
       apply (rule_tac r_s="r_f" in strong_disj_leq_use_env2)
        apply (rule_tac comm_strong_disj_use_env)
        apply (simp add: valid_exp_use_env_def)
        apply (simp add: sep_nres_map_def)
       apply (auto)
    (* proving the array itself still types *)
     apply (cut_tac env="env" and i="i" and n="0" and arr="arr" and arr'="arr'" and r_s="lift_use_env (comp_use_env rx2 (infl_use_env r_s2a r_s3)) r" and
      rs_list="rs_list" in well_typed_write_array)
         apply (auto)
     apply (rule_tac well_typed_lift_req)
      apply (rule_tac well_typed_lift_perms)
      apply (rule_tac infl_sexp_wp)
       apply (simp add: pure_fun_def)
      apply (rule_tac value_is_sexp)
      apply (auto)
     apply (rule_tac id_leq_use_env)
    (* proving the array is still proper *)
    apply (erule_tac x="ab" in allE)
    apply (auto)
    apply (rule_tac proper_add_mv)
     apply (simp add: add_env_def)
     apply (auto)
     apply (rule_tac v="v" in proper_write_array)
       apply (auto)
     apply (simp add: proper_exp_def)
    apply (rule_tac self_comp_leq_use_env1)*)
    (* proving validity of the new permission map: containment in state *)
   (*apply (simp add: valid_exp_use_env_def)
   apply (auto)*)
    apply (rule_tac add_sub_use_env)
    apply (rule_tac r_s="r_f" in trans_sub_use_env)
     apply (simp)
    apply (rule_tac self_diff_leq_use_env)
    (* separation *)(*
   apply (rule_tac add_sep_nres_map)
    apply (rule_tac r_s="r_f" in leq_sep_nres_map)
     apply (rule_tac self_diff_leq_use_env)
    apply (simp)
   apply (rule_tac strong_disj_comp_use_env1)
    apply (rule_tac r_s="r_f" in strong_disj_leq_use_env1)
     apply (simp add: sep_nres_map_def)
    apply (rule_tac self_diff_leq_use_env)
   apply (rule_tac diff_strong_disj_use_env)
   apply (rule_tac strong_lift_use_env)
   apply (simp)*)
    (* - action safety *)
  apply (rule_tac spec_infl_leq_use_env)
    apply (simp)
   apply (simp add: lift_comp_use_env)
   apply (rule_tac mini_disj_comp_use_env)
    apply (rule_tac r_s="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in mini_disj_leq_use_env2)
     apply (rule_tac r_s="comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex" in mini_disj_leq_use_env1)
      apply (rule_tac mini_disj_diff_use_env)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_comp_leq_use_env2)
    apply (simp)
   apply (simp add: infl_lift_use_env)
   apply (rule_tac gen_mini_disj_use_env2)
   apply (rule_tac infl_disj_use_env)
   apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
    apply (rule_tac self_diff_leq_use_env)
   apply (simp)
  apply (rule_tac strong_lift_use_env)
  apply (simp add: is_own_def)
  apply (simp add: corr_act_def)
  done
    
    
    (* ##### array read case ##### *)
  
lemma well_typed_lookup_array: "\<lbrakk> well_typed_state s env delta; read_array arr i = Some v; s x = Some (ArrValue arr); env (Loc x) = Some (ArrayTy tau) \<rbrakk> \<Longrightarrow>
  (well_typed_list env delta (one_use_env (Loc (delta x)) UsePerm) arr tau)"
  apply (simp add: well_typed_state_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (auto)
  done

lemma well_typed_list_elem: "\<lbrakk> well_typed_list env delta r_s arr tau; read_array arr (i :: int) = Some v \<rbrakk> \<Longrightarrow>
  (well_typed env delta r_s v tau r_s r_s \<and> is_value v)"    
  apply (induct arr arbitrary: i)
   apply (auto)
   apply (case_tac "i = 0")
    apply (auto)
  apply (case_tac "i = 0")
   apply (auto)
  done
    
lemma well_typed_lookup_array_elem: "\<lbrakk> well_typed_state s env delta; read_array arr (i :: int) = Some v; s x = Some (ArrValue arr); env (Loc x) = Some (ArrayTy tau) \<rbrakk> \<Longrightarrow>
  (unlim tau \<and> well_typed env delta (one_use_env (Loc (delta x)) UsePerm) v tau (one_use_env (Loc (delta x)) UsePerm) (one_use_env (Loc (delta x)) UsePerm) \<and> is_value v)"
  apply (simp add: well_typed_state_def)
  apply (auto)
    apply (erule_tac x="x" in allE)
    apply (auto)
   apply (erule_tac x="x" in allE)
   apply (auto)
   apply (cut_tac arr="arr" and i="i" in well_typed_list_elem)
     apply (auto)
  apply (erule_tac x="x" in allE)
  apply (auto)
  apply (cut_tac arr="arr" and i="i" in well_typed_list_elem)
    apply (auto)
  done    

    (*
lemma ack_exp_value: "\<lbrakk> is_value e \<rbrakk> \<Longrightarrow> is_value (set_own e a)"    
  apply (induct e)
        apply (auto)
   apply (case_tac x)
    apply (auto)
  apply (case_tac e1)
        apply (auto)
  done*)
  (*
lemma finish_is_value: "\<lbrakk> is_value e \<rbrakk> \<Longrightarrow> is_value (finish_value s e)"
  apply (induct e)
        apply (auto)
    apply (case_tac x2a)
      apply (auto)
   apply (case_tac x2a)
     apply (auto)
  apply (case_tac e1)
        apply (auto)
  done
    *)
lemma alpha_rename_is_value: "\<lbrakk> is_value e \<rbrakk> \<Longrightarrow> is_value (deep_alpha_rename e a b)"    
  apply (induct e)
        apply (auto)
   apply (case_tac x)
    apply (auto)
  apply (case_tac e1)
        apply (auto)
  done
    
lemma lam_var_remove_is_value: "\<lbrakk> is_value e \<rbrakk> \<Longrightarrow> is_value (lam_var_remove e a b)"    
  apply (induct e)
        apply (auto)
  apply (case_tac e1)
        apply (auto)
  done
    
lemma lam_var_list_remove_is_value: "\<lbrakk> is_value e \<rbrakk> \<Longrightarrow> is_value (lam_var_list_remove e vl)"    
  apply (induct vl arbitrary: e)
   apply (auto)
  apply (cut_tac e="e" and a="a" and b="b" in lam_var_remove_is_value)
   apply (auto)
  done    
(*
    
lemma proper_path_lookup: "\<lbrakk> rs_map a = Some r_s; proper_exp rs_map (VarExp (LocType a b)) \<rbrakk> \<Longrightarrow> (\<exists> l. path_lookup rs_map b l a)"
  apply (simp add: proper_exp_def)
  done
    
lemma read_proper_exp: "\<lbrakk> proper_list rs_map arr; read_array arr i = Some v \<rbrakk> \<Longrightarrow> proper_exp rs_map v"    
  apply (induct arr arbitrary: i)
   apply (auto)
  apply (case_tac "i = 0")
   apply (auto)
  done*)

lemma scv_read_case: 
  "\<lbrakk>well_typed_state s1 env delta; sub_use_env s1 r_f; leq_use_env r_s1 r_f; are = CVApp; leq_use_env r_s2aa r_s1;
        leq_use_env r_s2 (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)); leq_use_env rx1a r_s2aa;
        leq_use_env r_s2a (diff_use_env r_s3a (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa));
        leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s3; disj_use_env rx1 (lift_use_env rx2 r); leq_use_env rx r_s2;
        leq_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_s3a; leq_use_env r_ex r_s1; leq_use_env (app_req rx1 rx2 r tau r_ex) rx;
        leq_use_env r_exa r_s1;
        leq_use_env (app_req rx1a rx2a ra (FunTy IntTy tau r a) r_exa) rx1; c = ReadConst;
        FunTy t1a (FunTy IntTy tau r a) ra aa = pure_fun (ArrayTy t) (pure_fun IntTy t Ref) Prim; unlim t; v1 = VarExp (LocType ab); v2 = ConstExp (IConst i);
        ax = UseAct ab; s1 ab = Some (ArrValue arr); read_array arr i = Some v; s2 = s1; t1 = IntTy; env (Loc ab) = Some t1a;
        leq_use_env r_s3 r_s2a; leq_use_env rx2 r_s3; env (Loc (delta ab)) = Some tau_x; req_type t1a = Ref; req_type tau_x = Ref;
        leq_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_s2aa; leq_use_env r_s3a (diff_use_env r_s2aa (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb));
        leq_use_env rx2a r_s3a; leq_use_env r_exb r_s2aa;
        leq_use_env (diff_use_env (ereq_use_env (Loc (delta ab)) tau_x) (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)) rx2a\<rbrakk>
       \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (red_delta delta g_ax) (exp_red_use_env r_s1 g_ax) v tau (end_red_use_env r_s2 g_ax) (end_red_use_env rx g_ax) \<and>
                  well_typed_state s1 (red_env env g_ax) (red_delta delta g_ax) \<and>
                  sub_use_env s1 (exp_red_use_env r_f g_ax) \<and> safe_act s1 (infl_use_env r_f r_s2) g_ax \<and> corr_act (UseAct ab) g_ax"
    (* array read case *)
    (* - first we have to extract the type of e2. *)
  apply (cut_tac s="s1" and env="env" and i="i" and v="v" and x="ab" and arr="arr" in well_typed_lookup_array_elem)
      apply (auto)
   apply (simp add: pure_fun_def)
  apply (rule_tac x="ReadResAct" in exI)
  apply (auto)
    (* - the idea here is that e2 should be re-typed so that all of its permissions are encompassed by x3. *)
  apply (cut_tac env="env" and s="s1" in wts_mem_val_env)
   apply (auto)
  apply (case_tac "\<not> mem_ty tau_x")
   apply (simp add: mem_val_env_def)
   apply (erule_tac x="Loc (delta ab)" in allE)
   apply (auto)(*
  apply (cut_tac env="env" and r_x="r_x" and e="v" and tau="t" and t="tau_x" and b="b" and r_s="one_use_env (Loc b) UsePerm" and s="s1" in well_typed_set_own)
          apply (auto)
     apply (simp add: one_use_env_def)
    apply (simp add: well_typed_state_def)*)
  apply (simp add: mem_val_env_def)
  apply (erule_tac x="Loc (delta ab)" in allE)
  apply (auto)
    (* prelim: r_s2 \<le> r_s1 *)
  apply (cut_tac r_sc="r_s3" and r_sb="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa)" and r_sa="r_s1" in trans_leq_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (rule_tac r_sb="diff_use_env r_s2aa (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)" in trans_leq_use_env)
     apply (rule_tac diff_leq_use_env)
     apply (simp_all)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (auto)
  apply (cut_tac r_sc="r_s2" and r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" and r_sa="r_s1" in trans_leq_use_env)
    apply (rule_tac diff_leq_use_env)
    apply (auto)
    (* analysis based on whether x3 is in rx or not *)
  apply (case_tac "rx (Loc (delta ab)) \<noteq> NoPerm")
   apply (case_tac "\<not> leq_use_env (one_use_env (Loc (delta ab)) UsePerm) rx")
    apply (simp add: leq_use_env_def)
    apply (simp add: one_use_env_def)
    apply (auto)
    apply (case_tac "Loc (delta ab) = x")
     apply (auto)
    apply (case_tac "rx (Loc (delta ab))")
      apply (auto)
   apply (rule_tac ?r_s1.0="r_s2" in well_typed_incr_start_perm)
    apply (rule_tac rx="one_use_env (Loc (delta ab)) UsePerm" in well_typed_incr_req)
      apply (rule_tac r_s="one_use_env (Loc (delta ab)) UsePerm" in well_typed_incr_simul_perm)
       apply (rule_tac r_sb="rx" in trans_leq_use_env)
        apply (auto)
   apply (simp add: pure_fun_def)
    (* prelim: x3 \<le> r_s1 *)
  apply (cut_tac r_sc="one_use_env (Loc (delta ab)) UsePerm" and r_sb="ereq_use_env (Loc (delta ab)) tau_x" and r_sa="r_s1" in trans_leq_use_env)
    apply (rule_tac r_sb="r_s2aa" in trans_leq_use_env)
     apply (simp_all)
   apply (simp add: ereq_use_env_def)
   apply (simp add: leq_use_env_def)
   apply (simp add: one_use_env_def)
   apply (simp add: end_req_perm_def)
    (* case where t2 = Prim *)
  apply (simp add: app_req_def)
  apply (case_tac "req_type tau = Prim")
   apply (auto)
   apply (rule_tac ?r_s2.0="r_s1" and rx="empty_use_env" in well_typed_simul_end_perm)
      apply (rule_tac rx="one_use_env (Loc (delta ab)) UsePerm" in wt_sexp_no_req)
         apply (rule_tac r_s="one_use_env (Loc (delta ab)) UsePerm" in well_typed_incr_simul_perm)
          apply (auto)
     apply (simp add: pure_fun_def)
    apply (rule_tac wts_well_formed_delta)
    apply (auto)
   apply (rule_tac value_is_sexp)
   apply (simp)
    (* otherwise, since rx x3 = NoPerm, we prepare a diff *)
  apply (rule_tac ?r_s2.0="diff_use_env r_s1 (comp_use_env (comp_use_env (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)
          (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa))
          (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" and
      rx="diff_use_env (one_use_env (Loc (delta ab)) UsePerm) (comp_use_env (comp_use_env (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)
          (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa))
          (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex))" in well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac r_s="one_use_env (Loc (delta ab)) UsePerm" in well_typed_incr_simul_perm)
       apply (simp)
      apply (simp add: pure_fun_def)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac dist_comp_leq_use_env)
       apply (rule_tac r_sb="r_s2aa" in trans_leq_use_env)
        apply (auto)
      apply (rule_tac dist_comp_leq_use_env)
       apply (auto)
    apply (rule_tac dist_comp_leq_use_env)
      apply (auto)
     apply (rule_tac r_sb="r_s3a" in trans_leq_use_env)
      apply (rule_tac r_sb="diff_use_env r_s2aa (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)" in trans_leq_use_env)
       apply (rule_tac diff_leq_use_env)
       apply (auto)
    apply (rule_tac dist_comp_leq_use_env)
     apply (auto)
    apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
     apply (auto)
   apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
    apply (rule_tac rhs_unroll_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env)
    apply (rule_tac r_sb="diff_use_env r_s3a (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa)" in trans_leq_use_env)
     apply (rule_tac rhs_unroll_dcl_use_env)
     apply (rule_tac dist_diff_leq_use_env)
     apply (rule_tac r_sb="diff_use_env r_s2aa (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)" in trans_leq_use_env)
    apply (rule_tac dist_diff_leq_use_env)
      apply (auto)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (auto)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env1)
  apply (simp add: pure_fun_def)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1a rx2a) (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa)" in trans_leq_use_env)
   apply (auto)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env2)
  apply (rule_tac r_sb="diff_use_env (ereq_use_env (Loc (delta ab)) tau_x) (comp_use_env (ereq_use_env (Loc (delta ab)) tau_x) r_exb)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac dist_diff_leq_use_env)
  apply (simp add: ereq_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (simp add: one_use_env_def)
  apply (simp add: end_req_perm_def)
    (* to prove it is proper, we first have to do the lookup of deref_name x ab. *)(*
  apply (case_tac "rs_map ab = None")
   apply (case_tac "s1 ab = None")
    apply (simp)
   apply (simp add: well_typed_state_def)
   apply (simp add: valid_nres_map_def)
   apply (simp add: full_nres_map_def)
   apply (auto)
   apply (erule_tac x="ab" in allE)
   apply (auto)
  apply (cut_tac rs_map="rs_map" and a="ab" and b="b" in proper_path_lookup)
    apply (auto)
   apply (simp add: proper_exp_def)
    (* with this in mind, we can prove it is still proper after ack *)
  apply (rule_tac e="v" and a="ab" and b="b" and l="l" and r_s="y" and env="env" and r_se="r_x" and r_xe="r_x" in proper_set_own)
      apply (auto)
    (* - the value is proper from our definition of wts *)
    apply (simp add: well_typed_state_def)
    apply (auto)
    apply (erule_tac x="ab" in allE)
    apply (auto)
    apply (cut_tac arr="arr" and i="i" and v="v" in read_proper_exp)
      apply (auto)
   apply (rule_tac wts_mem_val_env)
   apply (auto)
    (* well-typedness since r_x \<le> y *)
  apply (rule_tac ?r_s1.0="r_x" in well_typed_incr_start_perm)
   apply (simp)
  apply (simp add: valid_res_list_def)
  apply (erule_tac x="i" in allE)
  apply (erule_tac x="r_x" in allE)
  apply (auto)
  apply (simp add: nres_lookup_def)*)
  apply (simp add: corr_act_def)
  done

    
lemma sares_cv_case: "
  \<lbrakk>well_typed_state s1 env delta; sub_use_env s1 r_f; leq_use_env r_s1 r_f; are = CVApp; e1 = AppExp (AppExp (ConstExp c) v1) v2;
        bin_const c; is_value v1; is_value v2; app_cv s1 c v1 v2 ax (s2, e2); FunTy t1a (FunTy t1 tau r a) ra aa \<in> const_type c;
        well_typed env delta r_s2a v2 t1 r_s3 rx2; leq_use_env r_s2aa r_s1;
        leq_use_env r_s2 (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)); leq_use_env rx1a r_s2aa;
        well_typed env delta r_s2aa v1 t1a r_s3a rx2a;
        leq_use_env r_s2a (diff_use_env r_s3a (comp_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_exa));
        leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s3; (*safe_use_lift rx2a ra;*) disj_use_env rx1 (lift_use_env rx2 r);
        leq_use_env rx r_s2; leq_use_env (comp_use_env rx1a (lift_use_env rx2a ra)) r_s3a; leq_use_env r_ex r_s1; leq_use_env (app_req rx1 rx2 r tau r_ex) rx;
        disj_use_env rx1a (lift_use_env rx2a ra); leq_use_env rx1 r_s2a; leq_use_env r_exa r_s1;
        leq_use_env (app_req rx1a rx2a ra (FunTy t1 tau r a) r_exa) rx1\<rbrakk>
       \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (red_delta delta g_ax) (exp_red_use_env r_s1 g_ax) e2 tau (end_red_use_env r_s2 g_ax) (end_red_use_env rx g_ax) \<and>
                  well_typed_state s2 (red_env env g_ax) (red_delta delta g_ax) \<and>
                  sub_use_env s2 (exp_red_use_env r_f g_ax) \<and> safe_act s1 (infl_use_env r_f r_s2) g_ax \<and> corr_act ax g_ax"
  apply (cut_tac env="env" in wts_mem_val_env)
  apply (auto)
  apply (case_tac c)
              apply (auto)(*
    (* array extension case *)
     apply (rule_tac scv_ext_array_alt)
              apply (auto)
       apply (simp add: pure_fun_def)
      apply (simp add: mem_val_env_def)
      apply (erule_tac x="Loc (delta ab)" in allE)
      apply (auto)
      apply (case_tac "tau_x")
            apply (auto)
     apply (simp add: ext_app_abbrev_def)
     apply (rule_tac x="t1" in exI)
     apply (rule_tac x="r" in exI)
     apply (rule_tac x="a" in exI)
     apply (rule_tac x="r_s2a" in exI)
     apply (rule_tac x="rx1" in exI)
     apply (simp add: ext_arr_abbrev_def)
     apply (auto)
     apply (rule_tac x="t1a" in exI)
     apply (rule_tac x="ra" in exI)
     apply (auto)
     apply (rule_tac x="r_s2aa" in exI)
     apply (auto)
    apply (simp add: pure_fun_def)*)
    (* array read case *)
    apply (rule_tac ?r_s3.0="r_s3" and r_ex="r_ex" and ?rx2.0="rx2" in scv_read_case)
                      apply (auto)
    apply (simp add: pure_fun_def)
   apply (simp add: mem_val_env_def)
   apply (erule_tac x="Loc (delta ab)" in allE)
   apply (auto)
   apply (case_tac "tau_x")
         apply (auto)
    (* array write case *)
  apply (rule_tac scv_write_case)
            apply (auto)
  apply (simp add: write_app_abbrev_def)
  apply (rule_tac x="PairTy IntTy t2 rb" in exI)
  apply (rule_tac x="r" in exI)
  apply (rule_tac x="a" in exI)
  apply (rule_tac x="r_s2a" in exI)
  apply (rule_tac x="rx1" in exI)
  apply (auto)
   apply (simp add: write_arr_abbrev_def)
   apply (rule_tac x="t1a" in exI)
   apply (rule_tac x="ra" in exI)
   apply (auto)
   apply (rule_tac x="r_s2aa" in exI)
   apply (auto)
  apply (simp add: write_pair_abbrev_def)
  apply (rule_tac x="rx2" in exI)
  apply (auto)
  apply (rule_tac x="r_s3" in exI)
  apply (auto)
  apply (rule_tac x="r_s2b" in exI)
  apply (auto)
done
    
end