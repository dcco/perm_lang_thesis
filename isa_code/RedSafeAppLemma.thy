theory RedSafeAppLemma
  imports RedSafeCV RedSafeCase SafeSubTPX
begin
    
    (* ##### sares *)
  
lemma sares_lam_helper: "\<lbrakk> well_typed env delta r_s1 e2 tau (diff_use_env (comp_use_env r_s3 r_exa) (comp_use_env rxa (lift_use_env rx2 r)))
      (diff_use_env (comp_use_env rxa rx2) (comp_use_env rxa (lift_use_env rx2 r))); non_prim_env env \<rbrakk> \<Longrightarrow>
  well_typed env delta r_s1 e2 tau (diff_use_env (comp_use_env r_s3 r_exa) (comp_use_env rxa (lift_use_env rx2 r))) (app_req rxa rx2 r tau empty_use_env)"
  apply (simp add: app_req_def)
  apply (auto)
   apply (rule_tac rx="diff_use_env (comp_use_env rxa rx2) (comp_use_env rxa (lift_use_env rx2 r))" in prim_type_no_req)
     apply (auto)
  apply (cut_tac r="comp_use_env rxa (lift_use_env rx2 r)" in comp_empty_use_env2)
  apply (auto)
  done 

lemma sares_fix_case: "\<lbrakk>well_typed_state s1 env delta; sub_use_env s1 r_f; app_red_exp FixApp (s1, AppExp (ConstExp FixConst) x62) ax (s2, e2);
        e1 = AppExp (ConstExp FixConst) x62; well_typed env delta r_s2a x62 t1 r_s3 rx2;
        leq_use_env r_s2 (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)); (*safe_use_lift rx2 r; safe_type t1 r;*)
        leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s3; disj_use_env rx1 (lift_use_env rx2 r); leq_use_env rx r_s2; leq_use_env r_ex r_s1;
        leq_use_env (app_req rx1 rx2 r tau r_ex) rx; leq_use_env r_s2a r_s1; leq_use_env rx1 r_s2a;
        FunTy t1 tau r a = pure_fun (pure_fun t t (req_type t)) t Prim; fun_ty t; unlim t; leq_use_env r_s1 r_f \<rbrakk>
       \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (red_delta delta g_ax) (exp_red_use_env r_s1 g_ax) e2 tau (end_red_use_env r_s2 g_ax) (end_red_use_env rx g_ax) \<and>
                  well_typed_state s2 (red_env env g_ax) (red_delta delta g_ax) \<and>
                  sub_use_env s2 (exp_red_use_env r_f g_ax) \<and> safe_act s1 (infl_use_env r_f r_s2) g_ax \<and> corr_act ax g_ax"
  apply (case_tac x62)
       apply (auto)
  apply (case_tac ax)
    apply (auto)
  apply (simp add: pure_fun_def)
  apply (auto)
    (* - prelim: rxa is weak *)
  apply (case_tac "\<not> weak_use_env rxa")
   apply (simp add: aff_use_env_def)
   apply (case_tac "req_type tau")
     apply (simp add: unlim_def)
    apply (simp)
   apply (simp add: null_use_env_def)
   apply (simp add: weak_use_env_def)
  apply (rule_tac x="NoResAct" in exI)
  apply (auto)
    (* e2 = x52 (Fix (\<lambda> x51. x52)). We can type the external app as: <<r_s1>> x52 <<r_s2a, rx1>> (Fix (\<lambda> x51. x52)) <<r_s3, rx2>>
      We can type the internal app as: <<r_s2a>> Fix <<r_s2a, {}>> (\<lambda> x51. x52) <<r_s2a, rxa>>
    *)
  apply (rule_tac ?r_s2.0="diff_use_env (diff_use_env r_s2a (comp_use_env rxa (lift_use_env rxa UsePerm))) (comp_use_env rx2 (comp_use_env r_exa r_ex))" and
        rx="diff_use_env (diff_use_env (comp_use_env rxa rxa) (comp_use_env rxa (lift_use_env rxa UsePerm))) (comp_use_env rx2 (comp_use_env r_exa r_ex))" in well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac t="tau" and ?rx1.0="rxa" and r_s'="r_s'" and r_end="r_end" and ?e1.0="x62a" and x="x61" and
          ?r_s2.0="r_s2a" and ?r_s3.0="r_s2a" and e'="AppExp (ConstExp FixConst) (LamExp x61 x62a)" in safe_subst_type_preserve_x)
               apply (auto)
         apply (rule_tac x="FunTy tau tau UsePerm (req_type tau)" in exI)
         apply (rule_tac x="UsePerm" in exI)
         apply (auto)
          apply (simp add: pure_fun_def)
         apply (rule_tac x="r_s2a" in exI)
         apply (auto)
          apply (rule_tac id_leq_use_env)
         apply (rule_tac x="empty_use_env" in exI)
         apply (auto)
          apply (rule_tac leq_empty_use_env)
         apply (case_tac "\<not> weak_use_env empty_use_env")
          apply (simp add: weak_use_env_def)
          apply (simp add: empty_use_env_def)
         apply (rule_tac x="rxa" in exI)
         apply (rule_tac x="r_s2a" in exI)
         apply (auto)
          apply (rule_tac x="rxa" in exI)
          apply (auto)
          apply (rule_tac x="empty_use_env" in exI)
          apply (auto)
            apply (rule_tac rhs_weak_leq_use_env)
             apply (auto)
            apply (rule_tac id_leq_use_env)
           apply (rule_tac leq_empty_use_env)
          apply (rule_tac self_diff_leq_use_env)
         apply (rule_tac x="empty_use_env" in exI)
         apply (auto)
              apply (rule_tac rhs_weak_leq_use_env)
               apply (rule_tac dist_weak_comp_use_env)
                apply (rule_tac dist_weak_comp_use_env)
                 apply (auto)(*
              apply (simp add: aff_use_env_def)
              apply (simp add: weak_use_env_def)*)
              apply (rule_tac id_leq_use_env)(*
             apply (simp add: aff_use_env_def)
             apply (case_tac "req_type tau")
               apply (simp add: unlim_def)
              apply (simp add: weak_use_env_def)
             apply (simp add: null_use_env_def)*)
            apply (rule_tac dist_comp_leq_use_env)
             apply (rule_tac leq_empty_use_env)
            apply (simp)
           apply (rule_tac disj_empty_use_env2)
          apply (rule_tac leq_empty_use_env)
         apply (simp add: app_req_def)
         apply (auto)
          apply (rule_tac leq_empty_use_env)
         apply (rule_tac diff_leq_use_env)
         apply (rule_tac dist_comp_leq_use_env)
          apply (rule_tac leq_empty_use_env)
         apply (rule_tac id_leq_use_env)
        apply (rule_tac wts_well_formed_delta)
        apply (auto)
       apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
        apply (auto)
      apply (rule_tac dist_comp_leq_use_env)
       apply (auto)
     apply (simp add: weak_use_env_def)
     apply (simp add: aff_use_env_def)
     apply (simp add: disj_use_env_def)
     apply (simp add: mini_disj_use_env_def)
    (* diff correctness *)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 rx2" in trans_leq_use_env)
       apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
        apply (rule_tac r_sb="diff_use_env r_s2a r_exa" in trans_leq_use_env)
         apply (rule_tac diff_leq_use_env)
         apply (simp_all)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
       apply (auto)
    (* prove bound shifts were valid. to show that r_s2 (the only end perm bound) is lower than r_s2a - rxa (our proposed bound),
        we use the fact that r_s2 \<le> r_s3 - rx2, and whatever is not removed by rx2 was already removed by r_exa from r_s2a.  *)
    apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
     apply (rule_tac r_sb="diff_use_env (diff_use_env r_s2a r_exa) (comp_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
      apply (rule_tac lhs_fold_dcl_use_env)
      apply (rule_tac dist_diff_leq_use_env_gen)
       apply (rule_tac rhs_weak_leq_use_env)
        apply (rule_tac dist_weak_comp_use_env)
         apply (simp_all)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac comp_leq_use_env2)
      apply (rule_tac comp_leq_use_env1)
      apply (rule_tac self_comp_leq_use_env2)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac self_comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env2)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac dist_diff_leq_use_env)
    apply (simp)
    (* proving the rx bound in the primitive case is predicated on the fact that rxa is null *)
  apply (simp add: app_req_def)
  apply (case_tac "req_type tau = Prim")
   apply (case_tac "\<not> leq_use_env rxa empty_use_env")
    apply (simp add: aff_use_env_def)
    apply (simp add: null_use_env_def)
    apply (simp add: leq_use_env_def)
   apply (rule_tac r_sb="empty_use_env" in trans_leq_use_env)
    apply (rule_tac leq_empty_use_env)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac dist_comp_leq_use_env)
    apply (auto)
    (* otherwise, to show that rx \<ge> rxa - (rxa + r_exa + r_ex) (our proposed bound). we note that rxa - r_exa \<le> rx2.
        rx \<ge> rx2 - (rx1 + rx2 + r_ex). rx1 is disjoint, rx2 is weak, r_ex is included in our bound *)    
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac r_sb="diff_use_env (diff_use_env rxa r_exa) (comp_use_env (comp_use_env rx1 rx2) r_ex)" in trans_leq_use_env)
   apply (rule_tac dist_diff_leq_use_env)
   apply (rule_tac comp_leq_use_env2)
   apply (simp)
  apply (rule_tac unroll_dcl_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac lhs_fold_dcl_use_env)
  apply (rule_tac lhs_flip_use_env)
  apply (rule_tac unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac disj_diff_leq_use_env)
   apply (rule_tac r_s="rx2" in disj_leq_use_env2)
    apply (simp)
   apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac dist_diff_leq_use_env)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac id_leq_use_env)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac diff_leq_use_env)
  apply (rule_tac dist_comp_leq_use_env)
   apply (rule_tac id_leq_use_env)
  apply (rule_tac id_leq_use_env)
  apply (simp add: corr_act_def)
  done
    
  
lemma sares_lam_case: "\<lbrakk>well_typed_state s2 env delta; sub_use_env s2  r_f; e1 = AppExp (LamExp x51 x52) x62; well_typed env delta r_s2a x62 t1 r_s3 rx2;
        leq_use_env r_s2 (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)); (*safe_use_lift rx2 r; safe_type t1 r;*)
        leq_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_s3; disj_use_env rx1 (lift_use_env rx2 r); leq_use_env rx r_s2; leq_use_env r_ex r_s1;
        leq_use_env (app_req rx1 rx2 r tau r_ex) rx; ax = NoAct; well_typed (add_env env (Var x51) t1) delta (add_use_env rxa (Var x51) r) x52 tau r_s' r_end; is_value x62;
        aff_use_env rxa a; safe_subst_exp x52 x51 x62 e2; s1 = s2; leq_use_env rxa r_s1; leq_use_env r_s2a (diff_use_env r_s1 r_exa); leq_use_env rx1 r_s2a;
        leq_use_env r_exa r_s1; leq_use_env (diff_use_env rxa r_exa) rx1; leq_use_env r_s1 r_f \<rbrakk>
       \<Longrightarrow> \<exists>g_ax. well_typed (red_env env g_ax) (red_delta delta g_ax) (exp_red_use_env r_s1 g_ax) e2 tau (end_red_use_env r_s2 g_ax) (end_red_use_env rx g_ax) \<and>
                  well_typed_state s2 (red_env env g_ax) (red_delta delta g_ax) \<and>
                  sub_use_env s2 (exp_red_use_env r_f g_ax) \<and> safe_act s2 (infl_use_env r_f r_s2) g_ax \<and> corr_act ax g_ax"
  apply (case_tac ax)
    apply (auto)
  apply (rule_tac x="NoResAct" in exI)
  apply (auto)
  apply (rule_tac ?r_s2.0="diff_use_env (diff_use_env (comp_use_env r_s3 (cut_use_env r_exa)) (comp_use_env rxa (lift_use_env rx2 r))) (comp_use_env r_exa (comp_use_env r_ex rx1))" and
      rx="diff_use_env (app_req rxa rx2 r tau empty_use_env) (comp_use_env r_exa (comp_use_env r_ex rx1))" in well_typed_simul_end_perm)
     apply (rule_tac well_typed_diff_end_perm)
      apply (rule_tac sares_lam_helper)
       apply (auto)
      apply (rule_tac x="x51" and t="t1" and ?rx1.0="rxa" and r="r" and ?e1.0="x52" and r_s'="r_s'" and r_end="r_end"
    and e'="x62" and ?r_s2.0="comp_use_env r_s2a (cut_use_env r_exa)" and ?r_s3.0="comp_use_env r_s3 (cut_use_env r_exa)" and ?rx2.0="rx2" in safe_subst_type_preserve_x)
               apply (auto)
          apply (case_tac x62)
                 apply (auto)
            apply (case_tac x3)
             apply (auto)
           apply (case_tac x71)
                 apply (auto)
           apply (case_tac x1)
                      apply (auto)
          apply (rule_tac well_typed_comp_perms_gen)
           apply (auto)
          apply (rule_tac r_s="r_s1" in mini_disj_strong_use_env)
           apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
            apply (rule_tac dist_diff_leq_use_env_gen)
             apply (rule_tac id_leq_use_env)
            apply (rule_tac self_cut_leq_use_env)
           apply (simp)
          apply (rule_tac strong_cut_use_env)
         apply (rule_tac wts_well_formed_delta)
         apply (auto)
        apply (rule_tac dist_comp_leq_use_env)
         apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
          apply (rule_tac self_diff_leq_use_env)
         apply (simp)
        apply (rule_tac cut_leq_use_env)
        apply (simp)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac st_diff_comp_leq_use_env)
        apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
         apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
          apply (simp)
         apply (rule_tac comp_leq_use_env1)
         apply (simp)
        apply (rule_tac diff_cut_leq_use_env)
        apply (rule_tac id_leq_use_env)
       apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (simp)
       apply (rule_tac self_comp_leq_use_env2)
    (* the last thing we have to do is show that rxa is disjoint from rx2. the idea is that rxa is contained in rx1 + cut r_exa. *)
      apply (rule_tac r_s="comp_use_env rx1 (cut_use_env r_exa)" in disj_leq_use_env1)
       apply (rule_tac disj_comp_use_env1)
        apply (simp)
       apply (rule_tac r_s="r_s2a" in disj_leq_use_env2)
        apply (simp add: disj_use_env_def)
        apply (auto)
         apply (rule_tac r_s="r_s1" in swp_mini_disj_use_env)
         apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
          apply (rule_tac dist_diff_leq_use_env_gen)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac self_cut_leq_use_env)
         apply (simp)
        apply (rule_tac r_s="r_s1" in mini_disj_strong_use_env)
         apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
          apply (rule_tac dist_diff_leq_use_env_gen)
           apply (rule_tac id_leq_use_env)
          apply (rule_tac self_cut_leq_use_env)
         apply (simp)
        apply (rule_tac strong_cut_use_env)
       apply (rule_tac r_sb="comp_use_env rx1 (lift_use_env rx2 r)" in trans_leq_use_env)
        apply (rule_tac r_sb="r_s3" in trans_leq_use_env)
         apply (rule_tac well_typed_perm_leq)
         apply (auto)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac st_diff_comp_leq_use_env)
      apply (rule_tac r_sb="diff_use_env rxa r_exa" in trans_leq_use_env)
       apply (simp)
      apply (rule_tac diff_cut_leq_use_env)
      apply (rule_tac id_leq_use_env)
     apply (rule_tac well_typed_state_non_prim_env)
      apply (auto)
    (* - proving initial boundary changes *)
    apply (rule_tac dist_comp_leq_use_env)
     apply (simp)
    apply (rule_tac dist_comp_leq_use_env)
     apply (simp)
    apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
     apply (rule_tac r_sb="diff_use_env r_s1 r_exa" in trans_leq_use_env)
      apply (rule_tac self_diff_leq_use_env)
     apply (auto)
   (*apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)*)
   apply (rule_tac r_sb="diff_use_env (diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)) r_exa" in trans_leq_use_env)
    apply (rule_tac fold_dcl_use_env)
    apply (rule_tac dist_diff_leq_use_env_gen)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac dist_comp_leq_use_env)
      apply (rule_tac r_sb="comp_use_env rx1 r_exa" in trans_leq_use_env)
       apply (rule_tac dist_comp_leq_use_env)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac comp_leq_use_env1)
        apply (rule_tac self_comp_leq_use_env1)
       apply (rule_tac self_comp_leq_use_env2)
      apply (rule_tac st_diff_comp_leq_use_env)
      apply (simp)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac comp_leq_use_env1)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac self_comp_leq_use_env2)
    apply (rule_tac comp_leq_use_env1)
    apply (rule_tac self_comp_leq_use_env1)
   apply (rule_tac mini_disj_diff_leq_use_env)
    apply (simp)
   apply (rule_tac r_s="diff_use_env r_s1 r_exa" in mini_disj_leq_use_env2)
    apply (rule_tac mini_disj_diff_use_env)
   apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
    apply (simp)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac well_typed_perm_leq)
   apply (auto)
    (* - secondary boundary change. *)
  apply (simp add: app_req_def)
  apply (auto)
   apply (rule_tac diff_leq_use_env)
   apply (rule_tac leq_empty_use_env)
  apply (rule_tac r_sb="diff_use_env (comp_use_env rx1 rx2) (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
   apply (simp)
  apply (rule_tac unroll_dcl_use_env)
  apply (rule_tac lhs_flip_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac rhs_flip_use_env)
  apply (rule_tac rhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env)
  apply (rule_tac lhs_fold_dcl_use_env)
  apply (rule_tac lhs_flip_use_env)
  apply (rule_tac lhs_unroll_dcl_use_env)
  apply (rule_tac dist_diff_leq_use_env_gen)
   apply (rule_tac lhs_dist_dcl_use_env)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac comp_leq_use_env1)
    apply (simp)
   apply (rule_tac comp_leq_use_env2)
   apply (rule_tac self_diff_leq_use_env)
  apply (rule_tac comp_leq_use_env1)
  apply (rule_tac self_comp_leq_use_env2)
  apply (simp add: corr_act_def)
  done
    
lemma empty_infl_use_env: "infl_use_env r_s r_s = empty_use_env"    
  apply (case_tac "\<forall> x. infl_use_env r_s r_s x = empty_use_env x")
   apply (auto)
  apply (simp add: infl_use_env_def)
  apply (simp add: empty_use_env_def)
  apply (case_tac "r_s x")
    apply (auto)
  done
  
lemma flat_infl_sexp_wp: "\<lbrakk> well_typed env delta r_s e tau r_s rx; well_formed_delta env delta; is_value e \<rbrakk> \<Longrightarrow> well_typed env delta rx e tau rx rx"    
  apply (cut_tac env="env" and ?r_s1.0="r_s" and e="e" and rx="rx" in infl_sexp_wp)
    apply (auto)
   apply (rule_tac value_is_sexp)
   apply (auto)
  apply (cut_tac r_s="r_s" in empty_infl_use_env)
  apply (auto)
  apply (cut_tac r="rx" in comp_empty_use_env2)
  apply (auto)
  done
    
lemma cancel_strong_leq_use_env: "\<lbrakk> strong_use_env r_x \<rbrakk> \<Longrightarrow> leq_use_env (diff_use_env r_x r_x) r_s"    
  apply (simp add: strong_use_env_def)
  apply (simp add: leq_use_env_def)
  apply (simp add: diff_use_env_def)
  apply (auto)
  apply (erule_tac x="x" in allE)
  apply (case_tac "r_x x")
    apply (auto)
  done
        
lemma infl_strong_use_env: "strong_use_env (infl_use_env r_s r_x)"    
  apply (simp add: strong_use_env_def)
  apply (simp add: infl_use_env_def)
  done
  
lemma strong_lift_use_env: "\<lbrakk> strong_use_env r_s \<rbrakk> \<Longrightarrow> lift_use_env r_s r = r_s"
  apply (case_tac "\<forall> x. lift_use_env r_s r x = r_s x")
   apply (auto)
  apply (simp add: strong_use_env_def)
  apply (erule_tac x="x" in allE)
  apply (case_tac r)
    apply (auto)
  apply (case_tac "r_s x")
    apply (auto)
  done
(*
lemma proper_op: "\<lbrakk> app_op xop c e \<rbrakk> \<Longrightarrow> proper_exp rs_map e"
  apply (simp add: proper_exp_def)    
  apply (case_tac xop)
       apply (auto)
  done
  *)  
lemma safe_app_red_exp_strict: "\<lbrakk> well_typed env delta r_s1 e1 tau r_s2 rx; well_typed_state s1 env delta;
  sub_use_env s1 r_f; leq_use_env r_s1 r_f; app_red_exp are (s1, e1) ax (s2, e2) \<rbrakk> \<Longrightarrow> (\<exists> g_ax.
  well_typed (red_env env g_ax) (red_delta delta g_ax) (exp_red_use_env r_s1 g_ax) e2 tau (end_red_use_env r_s2 g_ax) (end_red_use_env rx g_ax) \<and>
  (*red_env env ax env' \<and> *)well_typed_state s2 (red_env env g_ax) (red_delta delta g_ax) \<and>
  sub_use_env s2 (exp_red_use_env r_f g_ax) \<and> safe_act s1 (infl_use_env r_f r_s2) g_ax \<and> corr_act ax g_ax)"
  apply (case_tac are)
        apply (auto)
    (* lam case *)
        apply (rule_tac sares_lam_case)
                      apply (auto)
    (* fix-point case *)
       apply (rule_tac r_s2a="r_s2a" and ?r_s3.0="r_s3" in sares_fix_case)
                      apply (auto)
       apply (rule_tac x="rxa" in exI)
       apply (auto)
    (* remaining const cases. the idea is that any "destructive" uses should have had
      end perms removes to begin with, so red_use_env should be fine. *)
      apply (rule_tac ?r_s1.0="r_s1" and ?r_s2.0="r_s3" and ?rx1.0="rx1" and ?rx2.0="rx2" in safe_app_con_case)
             apply (auto)
       apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
        apply (auto)(*
      apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (rule_tac lhs_unroll_dcl_use_env)
       apply (rule_tac self_diff_leq_use_env)
      apply (simp)*)
    (* op case *)
     apply (case_tac "ax \<noteq> NoAct")
      apply (auto)
     apply (rule_tac x="NoResAct" in exI)
     apply (auto)
     apply (rule_tac ?r_s2.0="r_s1" and rx="empty_use_env" in well_typed_simul_end_perm)
        apply (rule_tac safe_app_op_case)
         apply (auto)
      apply (rule_tac r_sb="diff_use_env r_s3 (comp_use_env (comp_use_env rx1 (lift_use_env rx2 r)) r_ex)" in trans_leq_use_env)
       apply (rule_tac r_sb="r_s2a" in trans_leq_use_env)
        apply (auto)
      apply (rule_tac diff_leq_use_env)
      apply (simp)
     apply (rule_tac leq_empty_use_env)
  apply (simp add: corr_act_def)
    (* if case 1 *)
    apply (rule_tac x="NoResAct" in exI)
    apply (case_tac ax)
      apply (auto)
    apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
     apply (auto)
    apply (rule_tac rx="rx1" in well_typed_incr_req) 
      apply (simp)
     apply (rule_tac self_comp_leq_use_env1)
    apply (rule_tac dist_comp_leq_use_env)
     apply (rule_tac well_typed_perm_leqx)
     apply (auto)
    apply (rule_tac well_typed_perm_leqx)
     apply (auto)
  apply (simp add: corr_act_def)
    (* if case 2 *)
   apply (rule_tac x="NoResAct" in exI)
   apply (auto)
   apply (case_tac ax)
    apply (auto)
   apply (rule_tac ?r_s1.0="r_s2a" in well_typed_incr_start_perm)
    apply (auto)
  apply (rule_tac rx="rx2" in well_typed_incr_req)
     apply (simp)
    apply (rule_tac self_comp_leq_use_env2)
   apply (rule_tac dist_comp_leq_use_env)
    apply (rule_tac well_typed_perm_leqx)
    apply (auto)
   apply (rule_tac well_typed_perm_leqx)
   apply (auto)
  apply (simp add: corr_act_def)
    (* cv case *)
  apply (rule_tac sares_cv_case)
    apply (auto)
  done   

lemma sares_valid: "valid_reduct app_red_exp"
  apply (simp add: valid_reduct_def)
  apply (auto)
  apply (cut_tac env="env" and ?r_s1.0="r_s1" and ?e1.0="e1" and tau="tau" and ?r_s2.0="r_s2" and rx="rx" and
      ?s1.0="s1" and ax="ax" and ?s2.0="s2" and ?e2.0="e2" in safe_app_red_exp_strict)
       apply (auto)
  done

    
end